Directory structure:
└── henkisdabro-excel-taxonomy-cleaner/
    ├── README.md
    ├── ADDON_INSTRUCTIONS.md
    ├── CLAUDE.md
    ├── clsAppEvents.vb
    ├── DEPLOYMENT_CHECKLIST.md
    ├── install.ps1
    ├── RIBBON_SOLUTION.md
    ├── TaxonomyExtractorForm.vb
    └── TaxonomyExtractorModule.vb


Files Content:

================================================
FILE: README.md
================================================
# IPG Taxonomy Extractor AddIn for Excel v1.6.0

![Release](https://img.shields.io/github/v/release/henkisdabro/excel-taxonomy-cleaner)
![Language](https://img.shields.io/badge/language-VBA-blue)
![Platform](https://img.shields.io/badge/platform-Excel-green)
![License](https://img.shields.io/badge/license-MIT-yellow)

**Developer & Maintainer:** [@henkisdabro](https://github.com/henkisdabro)  
**Original Concept, Feature Contribution & User Testing:** [@stueydubs](https://github.com/stueydubs)

A professional VBA utility for extracting specific segments from pipe-delimited taxonomy data in Excel cells, featuring modeless operation, real-time updates, activation ID extraction, and custom undo functionality.

## 🎬 Demonstration

![EXCEL_AkzVTkjKyo](https://github.com/user-attachments/assets/97e7c216-2216-441d-a18e-2c86ca18c41b)

---

## Key Features

### 🎯 Flexible Extraction
- **9 Segments**: Extract any of the first 9 pipe-delimited segments
- **Activation IDs**: Extract unique identifiers after colon characters
- **Batch Processing**: Works with single cells or multiple selected ranges
- **Smart Parsing**: Handles missing segments gracefully
- **Live Preview**: See segment content before extraction
- **Enhanced UI**: Modern professional interface with smart data preview

### 🔄 Custom Undo System
Since Excel's built-in Undo doesn't work with VBA changes, this tool includes:
- **Automatic**: Original values stored before each extraction
- **UserForm**: Click "Undo Last" button 
- **Manual**: Run `UndoTaxonomyCleaning` macro
- **Instant**: Silent operation without confirmation dialogs
- **Smart**: Undo data cleared after each new operation

### 📦 Excel Add-in Ready
- **Professional Distribution**: PowerShell one-liner installation from GitHub
- **Universal Access**: Available in all Excel workbooks once installed
- **Ribbon Integration**: CustomUI XML embedded in XLAM for permanent ribbon buttons
- **Native Folder**: Installs to `%APPDATA%\Microsoft\AddIns` for optimal Excel integration
- **Follow instructions**: See `RIBBON_SOLUTION.md` for ribbon setup and `DEPLOYMENT_CHECKLIST.md` for distribution

---

## 🚀 **Fully Automated Installation**

Install instantly with this PowerShell one-liner:

```powershell
irm "https://raw.githubusercontent.com/henkisdabro/excel-taxonomy-cleaner/main/install.ps1?$(Get-Date -UFormat %s)" | iex
```

**What this does:**
- ✅ Downloads latest XLAM version from GitHub Releases
- ✅ Installs to native Excel AddIns folder (optimal compatibility)
- ✅ Configures security settings (trusted location + unblocked file)
- ✅ Registers with Excel for automatic loading
- ✅ Works without admin rights
- ✅ Complete setup in under 30 seconds

**Interactive Installation Experience:**
- 🎨 **Awesome ASCII Logo**: IPG logo!
- 📊 **Real-time Progress Tracker**: Live progress bars showing installation steps
- ⚡ **Animated Interface**: Spinning indicators and step-by-step completion status
- 🎯 **Smart Registry Management**: Automatically removes old version registry entries
- 🔄 **Upgrade Protection**: Prevents duplicate registry keys when re-installing same version
- 🖥️ **REPL-style Interface**: Modern CLI experience with consistent frame layouts
- 🎉 **Clean Success Messages**: Minimal, focused completion information

**After installation:**
- The add-in loads automatically when Excel starts
- The **IPG Taxonomy Extractor** button appears in the **IPG Tools** group on the Home tab
- If ribbon doesn't appear, see `RIBBON_SOLUTION.md` for CustomUI XML setup
- Alternative access: File → Options → Add-ins → Excel Add-ins → Go → Browse

**To uninstall:**
Go to File → Options → Add-ins → Excel Add-ins → Go → Uncheck the add-in

---

## 🔄 Upgrading to a New Version

### Automatic Upgrade (Recommended)
```powershell
# Simply run the installer again - it handles everything
irm "https://raw.githubusercontent.com/henkisdabro/excel-taxonomy-cleaner/main/install.ps1?$(Get-Date -UFormat %s)" | iex
```

**What the installer does automatically:**
- ✅ Downloads the latest version from GitHub
- ✅ Removes all old versions from your AddIns folder
- ✅ Cleans orphaned registry entries from previous versions
- ✅ Installs the new version with progress tracking
- ✅ Updates registry entries (prevents duplicates)
- ✅ Preserves your settings
- ✅ Shows real-time progress with animated interface

### Manual Upgrade
If you prefer manual control:

1. **Download new version** from [Releases](https://github.com/henkisdabro/excel-taxonomy-cleaner/releases/latest)
2. **In Excel**: File → Options → Add-ins → Excel Add-ins → Go
3. **Uncheck old version** (e.g., previous version)
4. **Click Browse** → Navigate to new XLAM file → OK
5. **Check the new version** → OK

**After Upgrade:**
- The new version ribbon button will appear in the IPG Tools group
- All your Excel workbooks will use the updated add-in
- Old functionality remains the same with new improvements

### Troubleshooting Upgrades

**If you see multiple versions:**
1. Go to File → Options → Add-ins → Excel Add-ins → Go
2. Uncheck ALL old versions
3. Only keep the latest version checked

**If upgrade fails:**
1. Manually delete old files from: `%APPDATA%\Microsoft\AddIns`
2. Run the PowerShell installer again
3. Restart Excel

---

## ✨ What's New in v1.6.0

### 🔄 Multi-Step Undo System
- **Professional Undo Stack** - Up to 10 sequential operations with LIFO (Last In, First Out) behavior
- **Dynamic Button Captions** - Shows operation count: "Undo Last" → "Undo Last (3)" → "Undo Last (1)"
- **Step-by-Step Reversal** - Undo operations individually in reverse order as expected
- **Capacity Warning** - Visual warning when undo limit reached (10/10)
- **Processing Feedback** - Button shows "Processing..." with disabled appearance during operations

### 🎯 Enhanced User Experience
- **Immediate Focus** - UserForm gets focus immediately when launched from ribbon
- **Smart Focus Management** - Focus returns to clicked buttons after operations, preventing unwanted focus jumps
- **Rapid Click Protection** - Prevents undo operation queuing with visual feedback during processing
- **Consistent UI Behavior** - All extraction buttons maintain focus, Close button no longer steals focus

## Previous Updates - v1.5.0

### 🎯 Smart Targeting Acronym Trimming
- **Intelligent Detection** - Smart overlay button appears automatically when targeting patterns (^ABC^) are detected in cells without pipes
- **Seamless Removal** - One-click removal of targeting text like ^AT^, ^ACX123^, ^FB_Campaign^ 
- **Full Undo Support** - Complete integration with existing undo system
- **Modeless Integration** - Works perfectly with continuous workflow operation

## Previous Updates - v1.4.0

### 🚀 Revolutionary Modeless Operation
- **Keep form open** while working with Excel - no more reopening the form for each extraction
- **Excel remains fully interactive** - click, select, and navigate normally with the form still open
- **Continuous workflow** - select different ranges and extract without interruption

### 🎯 Real-time Interface Updates
- **Automatic refresh** - buttons update instantly when you select new cells with taxonomy data
- **Live preview** - see exactly what segments are available in your currently selected data
- **Cell count display** - shows how many cells will be processed with each extraction

### 🔄 Smart Data Validation
- **Pipe validation** - buttons show "N/A" and are disabled for data without pipe delimiters
- **Post-extraction refresh** - interface immediately updates after extraction to show current state
- **Intelligent button behavior** - only show extractable segments for cleaner interface

---

## Example Usage

For text: `FY24_26|Q1-4|Tourism WA|WA |Always On Remarketing| 4LAOSO | SOC|Facebook_Instagram|Conversions:DJTDOM060725`

- **Segment 1** → `FY24_26`
- **Segment 3** → `Tourism WA` 
- **Segment 5** → `Always On Remarketing`
- **Segment 8** → `Facebook_Instagram`
- **Segment 9** → `Conversions` (text after 8th pipe, before colon)
- **Activation ID** → `DJTDOM060725` (text after colon)

---

## Interface Options

### Modeless UserForm (New in v1.4.0)
- **Continuous operation** - form stays open while Excel remains interactive
- **Real-time updates** - interface automatically refreshes when you select new cells
- **Multi-range workflow** - process different ranges without reopening the form
- **Cell count display** - shows exactly how many cells will be processed
- **Smart validation** - only shows available segments, disables unavailable ones
- Run `TaxonomyExtractorModeless` macro to launch

### Traditional Modal UserForm
- Beautiful interface with 9 segment buttons + Activation ID button
- **Smart Label Display**: Shows complete preview of selected data
- **Dynamic Button Captions**: Buttons show preview of each segment content
- **Context-Aware Interface**: Adapts to your selected data automatically
- **Smart Positioning**: Centers within Excel window while preserving your form size
- Built-in "Undo Last" button for quick reversal
- Run `TaxonomyExtractor` macro to launch

### Basic InputBox (Fallback)
- Simple text input dialog
- Works immediately if UserForm not created
- Type 1-9 to select segment, or 'A' for Activation ID
- Run `UndoTaxonomyCleaning` macro to undo changes

---

## Usage Workflow

### Modeless Interface (Continuous Operation - v1.4.0)
1. **Select cells** with pipe-delimited taxonomy data
2. **Click "IPG Taxonomy Extractor"** button in the IPG Tools group on Home tab
3. **Form stays open** - Excel remains fully interactive
4. **Select different cells** - form automatically updates to show new data
5. **Click segment button** (1-9) or "Activation ID" - processes currently selected cells
6. **Continue selecting** new ranges and extracting without reopening form
7. **Use "Undo Last"** button for instant reversal
8. **Click "Close"** when finished

### Traditional Modal Interface
1. **Select cells** with pipe-delimited data
2. **Run `TaxonomyExtractor`** macro or click ribbon button
3. **See your data preview** - label shows complete content, buttons show segment previews
4. **Click segment button** (1-9) or "Activation ID" - extraction happens instantly
5. **Review results** - use "Undo Last" button for instant reversal if needed
6. **Click "Close"** when finished

---

## Data Format Support

### IPG Interact Taxonomy Format
This tool is specifically designed to work with the taxonomy format outputted from the **IPG Interact Taxonomy tool**. This format is used consistently across:
- **Campaign names**
- **Insertion Order names** 
- **Ad group names**
- **Line item names**
- **Ad names**

### Standard Format
```
segment1|segment2|segment3|segment4|segment5|segment6|segment7|segment8|segment9:activationID
```

### Real-World Example
```
FY24_26|Q1-4|Tourism WA|WA |Always On Remarketing| 4LAOSO | SOC|Facebook_Instagram|Conversions:DJTDOM060725
```

### Edge Cases Handled
- **Missing segments**: Processes available segments, skips others
- **No colons**: Segment 9 extracts to end of text
- **Empty cells**: Skipped automatically
- **Mixed data**: Each cell processed independently

---

## Installation Methods

### Method 1: One-Click PowerShell (Recommended)
Use the PowerShell command at the top of this README - it handles everything automatically.

### Method 2: Manual VBA Setup (Development)
1. **Copy the main code**: Use `TaxonomyExtractorModule.vb` - copy this code into an Excel VBA module
2. **Create the UserForm**: Follow instructions in `TaxonomyExtractorForm.vb` to create the interface
3. **Run macro**: Execute `TaxonomyExtractor` or `TaxonomyExtractorModeless` macro
4. **Choose option**: Click segment button (1-9) or Activation ID button

### Method 3: Manual Add-in Installation (Legacy)
1. Complete Method 2 setup above
2. Save as Excel Add-in (.xlam) format
3. Install via File → Options → Add-ins
4. Available in ALL Excel workbooks automatically
5. Perfect for team distribution

---

## Technical Highlights

- **Modeless Operation**: Revolutionary continuous workflow without interrupting Excel
- **Real-time Updates**: Interface adapts instantly to new data selections
- **Application Event Management**: Proper Excel integration with automatic cleanup
- **Robust Error Handling**: Prevents crashes during batch processing
- **Performance Optimized**: Screen updating control for smooth operation
- **Memory Efficient**: Automatic cleanup of undo data and event handlers
- **Silent Operation**: No interruptions - only error messages when needed
- **Professional UI**: Looks and feels like built-in Excel tools
- **Context-Aware Display**: Interface adapts to show your actual data content

---

## Files

- **`TaxonomyExtractorModule.vb`** - Main VBA code with all functionality and modeless operation
- **`TaxonomyExtractorForm.vb`** - UserForm setup instructions and button code  
- **`clsAppEvents.vb`** - Application event handler for modeless operation
- **`install.ps1`** - PowerShell installation script for GitHub one-liner deployment
- **`RIBBON_SOLUTION.md`** - Complete guide for embedding CustomUI ribbon buttons in XLAM
- **`DEPLOYMENT_CHECKLIST.md`** - Production deployment guide and testing procedures
- **`ADDON_INSTRUCTIONS.md`** - Manual Excel Add-in creation guide
- **`CLAUDE.md`** - Development documentation and architecture notes

---

## Version History

### v1.6.0 (Latest)
- **Multi-Step Undo System**: Professional undo stack supporting up to 10 sequential operations with LIFO behavior
- **Dynamic Button Captions**: Real-time operation count display ("Undo Last (3)") with automatic updates
- **Enhanced User Experience**: Immediate focus management, smart focus restoration, and rapid click protection
- **Processing Feedback**: Visual "Processing..." state with disabled appearance during undo operations
- **Capacity Management**: Warning label when undo limit reached with automatic oldest operation removal

### v1.5.0
- **Smart Targeting Acronym Trimming**: Intelligent overlay button for removing targeting patterns (^ABC^) from cells without pipes
- **Enhanced Detection Logic**: Automatically detects targeting patterns and enables seamless removal
- **Full Undo Integration**: Complete integration with existing undo system for acronym trimming
- **Modeless Operation Enhancement**: Perfect integration with continuous workflow operation

### v1.4.0
- **Revolutionary Modeless Operation**: Keep form open while Excel remains fully interactive
- **Real-time Interface Updates**: Buttons automatically refresh when selecting new cells
- **Smart Pipe Validation**: Buttons show "N/A" for single values without pipe delimiters
- **Post-extraction Refresh**: Interface immediately reflects extraction results
- **Selected Cell Count Display**: Shows exactly how many cells will be processed
- **Enhanced UX Workflow**: Seamless batch processing for multiple data ranges 
- **Application Event Management**: Proper Excel integration with automatic cleanup
- **Ribbon Button Enhancement**: Launches superior modeless version by default

### v1.3.0
- **Smart Positioning System**: UserForm now centers perfectly within Excel window
- **Respects Design Dimensions**: Preserves UserForm's design-time Width and Height properties
- **Enhanced Install Script**: Automatically removes old versions during upgrades
- **Improved Developer Workflow**: Comprehensive release process documentation
- **User Upgrade Instructions**: Clear upgrade path for existing users
- **Version Management**: Systematic approach to version increments and releases

### v1.2.0
- **Enhanced UserForm Interface**: Modern professional UI with smart data preview
- **Dynamic Button Captions**: Buttons show actual segment content from your data
- **Smart Label Display**: Complete preview of selected data
- **Context-Aware Parsing**: Automatically analyzes first selected cell
- **Smart Positioning**: Centers UserForm within Excel window while respecting design dimensions
- **PowerShell One-Liner Installation**: GitHub-hosted automated deployment
- **Native AddIns Folder**: Optimal Excel integration and compatibility
- **CustomUI Ribbon Support**: Embedded ribbon buttons for professional distribution
- **Improved Error Handling**: More robust validation and processing
- **Silent Operation**: No unnecessary confirmation dialogs
- **Performance Optimizations**: Better memory management and screen updating

### v1.1.0
- Added professional UserForm with 9 segment buttons
- Custom undo functionality
- Excel Add-in support

### v1.0.0
- Initial release with basic InputBox interface
- Core segment extraction functionality

---

## 🛠️ Developer Workflow - Building New Releases

This section is for developers maintaining and improving the Excel Taxonomy Extractor codebase.

### When to Increment Version

**Follow Semantic Versioning (SemVer):**
- ✅ **Major (X.0.0)**: Breaking changes that affect existing functionality
- ✅ **Minor (X.Y.0)**: New features, UI improvements, or significant enhancements
- ✅ **Patch (X.Y.Z)**: Bug fixes, small improvements, or performance optimizations

**Version Locations to Update:**
1. `TaxonomyExtractorForm.vb` - UserForm caption with new version number
2. `TaxonomyExtractorModule.vb` - Error messages with new version number
3. `install.ps1` - Script header, AddInName, DisplayName with new version
4. `README.md` - Main heading and version history section
5. `CLAUDE.md` - Project overview version references

### Step-by-Step Release Process

#### 1. **Code Development & Testing**
```bash
# Create feature branch
git checkout -b feature-name

# Make your VB code changes in:
# - TaxonomyExtractorModule.vb
# - TaxonomyExtractorForm.vb

# Update version numbers in all files listed above
# Test thoroughly in Excel VBA environment
```

#### 2. **Update Documentation**
- Update `README.md` version history with new features
- Update `CLAUDE.md` with technical changes
- Commit all code and documentation changes

#### 3. **Build XLAM Binary**
**Critical: Build the XLAM from the PREVIOUS release, not from scratch**

```bash
# Download the current release XLAM file
# Go to: https://github.com/henkisdabro/excel-taxonomy-cleaner/releases/latest
# Download the latest XLAM file (e.g., ipg_taxonomy_extractor_addonvX.Y.Z.xlam)
```

**In Excel:**
1. **Open the downloaded XLAM** from the previous release
2. **Press Alt+F11** to open VBA Editor
3. **Replace the VB code** with your updated code:
   - Copy new `TaxonomyExtractorModule.vb` content into the existing module
   - Update `TaxonomyExtractorForm` with new form code
4. **Verify the ribbon CustomUI XML** is still embedded (should be preserved)
5. **Test the functionality** thoroughly
6. **Save as new version**: `File → Save As` → `ipg_taxonomy_extractor_addonvX.Y.Z.xlam` (using semantic versioning)
7. **Close Excel**

#### 4. **Create GitHub Release**
```bash
# Push your branch and create PR
git push origin feature-name

# After merging to main:
git checkout main
git pull origin main

# Create and push tag (using semantic versioning)
git tag vX.Y.Z
git push origin vX.Y.Z
```

**On GitHub:**
1. Go to **Releases** → **Create a new release**
2. **Tag**: `vX.Y.Z` (semantic version)
3. **Title**: `Excel Taxonomy Extractor vX.Y.Z`
4. **Description**: List new features, improvements, and bug fixes
5. **Upload the XLAM file**: `ipg_taxonomy_extractor_addonvX.Y.Z.xlam`
6. **Publish release**

#### 5. **Verify Installation**
Test the PowerShell installer picks up the new version:
```powershell
irm "https://raw.githubusercontent.com/henkisdabro/excel-taxonomy-cleaner/main/install.ps1?$(Get-Date -UFormat %s)" | iex
```

### 🎯 **Developer Checklist**
- [ ] Version numbers updated in all 5 locations (following semantic versioning)
- [ ] VB code tested in Excel environment
- [ ] Documentation updated (README.md, CLAUDE.md)
- [ ] XLAM built from previous release (preserves CustomUI)
- [ ] GitHub release created with proper semantic version tag
- [ ] XLAM binary uploaded to release with correct filename
- [ ] PowerShell installer tested with new version
- [ ] Old version cleanup verified in install script

---

## Support

See `CLAUDE.md` for detailed development documentation and `ADDON_INSTRUCTIONS.md` for complete add-in creation guide.

Ready to streamline your taxonomy data extraction! 🚀



================================================
FILE: ADDON_INSTRUCTIONS.md
================================================
# Excel Taxonomy Extractor Add-in Installation

## What You Get
- **Professional UserForm** with 9 segment buttons + Activation ID button
- **Ribbon button** for easy access
- **Custom undo functionality** (Excel's undo doesn't work with VBA)
- **Works in any Excel workbook** once installed

## Installation Steps

### 1. Create the Add-in File
1. **Open your working Excel file** (the one with TaxonomyExtractor)
2. **File** → **Save As**
3. **File Type**: Choose **"Excel Add-in (*.xlam)"**
4. **File Name**: `TaxonomyExtractor.xlam`
5. **Location**: Use the default Add-ins folder Excel suggests
6. **Save**

### 2. Install the Add-in
1. **File** → **Options** → **Add-ins**
2. **Manage**: Select "Excel Add-ins" → **Go**
3. **Browse** → Find your `TaxonomyExtractor.xlam` file
4. **Check the box** next to "TaxonomyExtractor" 
5. **OK**

### 3. Verify Installation
- **Open any Excel workbook**
- **Look for your ribbon button** (should appear on ribbon)
- **Test**: Select cells with pipe-delimited data and click the button

## Usage

### Example Data
```
FY24_26|Q1-4|Tourism WA|WA |Always On Remarketing| 4LAOSO | SOC|Facebook_Instagram|Conversions:DJTDOM060725
```

### Extract Segments
1. **Select cells** containing pipe-delimited text
2. **Click your ribbon button** (or run `TaxonomyExtractor` macro)
3. **Click desired segment button**:
   - **Segment 1** → `FY24_26`
   - **Segment 3** → `Tourism WA`
   - **Segment 5** → `Always On Remarketing`
   - **Segment 9** → `Conversions`
   - **Activation ID** → `DJTDOM060725`

### Undo Changes
- **Click "Undo Last"** button in the dialog (instant, no confirmation)
- **Or run** `UndoTaxonomyCleaning` macro manually

## File Components

Your add-in contains:
- **`TaxonomyExtractorModule.vb`** - Main VBA code
- **`TaxonomyExtractorForm`** - UserForm with buttons
- **Ribbon customization** - Your custom button

## Distribution

To share with others:
1. **Copy the `.xlam` file** to their computer
2. **They follow steps 2-3** above to install
3. **Works immediately** in all their Excel workbooks

## Troubleshooting

### Add-in not appearing
- Check **File** → **Options** → **Add-ins** → Make sure it's checked
- Try **Browse** to find the `.xlam` file again

### Button not working
- Make sure UserForm is named exactly `TaxonomyExtractorForm`
- Verify all button names match the VBA code

### "File not found" error
- The module code is already updated for `TaxonomyExtractorForm`
- Make sure the UserForm exists in the add-in

## Benefits of Add-in Format

✅ **Available in all workbooks** - no need to copy code each time  
✅ **Professional deployment** - easy to install and share  
✅ **Automatic loading** - appears whenever Excel starts  
✅ **Centralized updates** - update once, works everywhere  
✅ **Clean ribbon integration** - your button appears automatically  

🚀 **Your taxonomy extraction tool is now a professional Excel add-in!**


================================================
FILE: CLAUDE.md
================================================
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview - Version 1.6.0

Advanced VBA utility for Excel providing flexible extraction of specific segments from pipe-delimited taxonomy data with activation ID support. Features professional UI with 9 segment buttons, modeless operation, real-time updates, multi-step undo functionality, and Excel Add-in deployment.

**Version 1.6.0 introduces a comprehensive multi-step undo system supporting up to 10 sequential operations with LIFO behavior, dynamic button captions showing operation counts, enhanced focus management, and professional processing feedback during undo operations.**

## Architecture & Key Components

### Core Features
- **Enhanced Range Support**: Single cells or multiple selected ranges
- **Modeless Operation** (v1.4.0): Form stays open while Excel remains interactive
- **Real-time Updates** (v1.4.0): Button content updates automatically when selection changes
- **Smart Data Preview**: Full selected data display with dynamic button captions
- **Context-Aware Parsing**: Automatically parses first selected cell into individual segments
- **Pipe Validation** (v1.4.0): Requires pipes for segment display, shows "N/A" for single values
- **Custom Undo System**: Works where Excel's built-in undo cannot (VBA changes)
- **Professional UI**: Smart positioning, dynamic previews, silent operation

### Main Components
- **`TaxonomyExtractor`**: Modal entry point, validates selection and launches UI
- **`TaxonomyExtractorModeless`** (v1.4.0): Modeless entry with real-time updates
- **`clsAppEvents`** (v1.4.0): Monitors Excel selection changes for modeless operation
- **`ParseFirstCellData`**: Parses cells into segments and activation ID
- **`ExtractPipeSegment`** / **`ExtractActivationID`**: Core extraction logic
- **`UndoTaxonomyCleaning`**: Custom undo with automatic value storage
- **`TaxonomyExtractorForm`**: Professional 9-button interface with dynamic content

## Development Environment

### Requirements
- Microsoft Excel with VBA support enabled
- No external dependencies

### File Structure
- **TaxonomyExtractorModule.vb**: Main VBA module with core functionality
- **TaxonomyExtractorForm.vb**: UserForm code and setup instructions
- **install.ps1**: PowerShell installation script for GitHub deployment
- **RIBBON_SOLUTION.md**: CustomUI ribbon embedding guide
- **DEPLOYMENT_CHECKLIST.md**: Production deployment guide

### Testing Workflow
1. Open Excel → Alt + F11 → Insert Module
2. Copy code from `TaxonomyExtractorModule.vb`
3. Create UserForm per `TaxonomyExtractorForm.vb` instructions
4. Test with sample pipe-delimited data

### Usage Workflows

#### Modeless Interface (Recommended - v1.4.0+)
1. Select cells with pipe-delimited text → Run `TaxonomyExtractorModeless`
2. Form stays open, Excel remains interactive
3. Select different cells → Form auto-updates with new data
4. Click segment buttons → Processes currently selected cells
5. Continue selecting and extracting without reopening
6. Use "Undo Last" for instant reversal

#### Traditional Modal Interface
1. Select cells → Run `TaxonomyExtractor` → UserForm appears
2. See data preview and segment button previews
3. Click segment button → Instant extraction, no confirmations
4. Use "Undo Last" for reversal → Close when finished

## Data Format Support

### IPG Interact Taxonomy Format
Designed for taxonomy format from **IPG Interact Taxonomy tool** used across Campaign names, Insertion Order names, Ad group names, Line item names, and Ad names.

**Format**: `segment1|segment2|segment3|segment4|segment5|segment6|segment7|segment8|segment9:activationID`

**Example**: `FY24_26|Q1-4|Tourism WA|WA |Always On Remarketing| 4LAOSO | SOC|Facebook_Instagram|Conversions:DJTDOM060725`

**Extraction Results**:
- Segment 1: `FY24_26` | Segment 3: `Tourism WA` | Segment 5: `Always On Remarketing`
- Segment 8: `Facebook_Instagram` | Segment 9: `Conversions` | Activation ID: `DJTDOM060725`

## Deployment Options

### Option 1: GitHub PowerShell Installation (Recommended)
```powershell
irm "https://raw.githubusercontent.com/henkisdabro/excel-taxonomy-cleaner/main/install.ps1" | iex
```
- Downloads latest XLAM from GitHub Releases
- Installs to `%APPDATA%\Microsoft\AddIns`
- Configures security (trusted location + unblocking)
- Registers with Excel for auto-loading
- Works without admin rights

### Option 2: Manual VBA Setup (Development)
1. Copy `TaxonomyExtractorModule.vb` into Excel VBA module
2. Create UserForm per `TaxonomyExtractorForm.vb` instructions
3. Save as `.xlsm` format

### Option 3: Manual XLAM Installation (Legacy)
1. Complete Option 2 → Save as `.xlam`
2. Install via File → Options → Add-ins

## Technical Implementation

### UserForm Requirements
- Must be named `TaxonomyExtractorForm`
- Must have `SetParsedData(parsedData As ParsedCellData)` method
- Falls back to InputBox if UserForm missing

### Data Structure
- `ParsedCellData` type with Segment1-Segment9, ActivationID variables
- Includes original text and truncated display text

### Event Management (v1.4.0)
- `clsAppEvents.App_SheetSelectionChange()`: Monitors selection changes
- `RefreshModelessFormIfOpen()`: Updates UI after operations
- `CleanupModelessEvents()`: Prevents memory leaks

## Version Management Guidelines

### ⚠️ CRITICAL VERSION UPDATE CHECKLIST

**Every version increment MUST update ALL these locations:**

#### 🎯 PRIMARY VERSION LOCATIONS:
1. **install.ps1**:
   - Line 1: `# Excel Taxonomy Cleaner v1.X.X - One-Click Installation Script`
   - Line 14: `$AddInName = "ipg_taxonomy_extractor_addonv1.X.X.xlam"`
   - Line 15: `$DisplayName = "Excel Taxonomy Cleaner v1.X.X"`
   - Line ~208: ASCII logo header with version
   - Line ~585: Installation prompt with version

2. **TaxonomyExtractorForm.vb**: 
   - Line ~132: `Me.Caption = "IPG Mediabrands Taxonomy Extractor v1.X.X"`

3. **TaxonomyExtractorModule.vb**: 
   - Line ~673: Error message version string
   - Line ~685: Error message version string (Modeless)

4. **README.md**: Line 1: `# Excel Taxonomy Extractor v1.X.X`

5. **CLAUDE.md**: Line 5: `## Project Overview - Version 1.X.X`

6. **clsAppEvents.vb**: 
   - Line 2: `' Part of IPG Mediabrands Taxonomy Extractor v1.X.X`

7. **DEPLOYMENT_CHECKLIST.md**:
   - Line 1: Title with version
   - GitHub release command examples

#### 🚨 FAILURE CONSEQUENCES:
- **install.ps1 not updated**: Users get 404 errors, broken installation
- **VBA files not updated**: Incorrect version display, user confusion

#### 📋 VERSION UPDATE WORKFLOW:
1. Update install.ps1 filename and all version references
2. Update all VBA version strings
3. Update documentation files
4. Search repo for old version numbers: `grep -r "v1\.[0-9]\.[0-9]" .`
5. Ensure install.ps1 matches planned GitHub Release asset filename

### Version Increment Guidelines
- **Major (X.0.0)**: Breaking changes, architecture changes, UI overhauls
- **Minor (X.Y.0)**: New features, significant enhancements, performance improvements
- **Patch (X.Y.Z)**: Bug fixes, small improvements, documentation updates

## Interactive Installer Architecture (v1.5.0+)

### 🎯 Enhanced Version Requirements

**Additional v1.5.0 Interactive Interface Locations:**
- install.ps1 Line ~553: `"Initializing IPG Taxonomy Extractor AddIn Installer..."`
- install.ps1 Line ~558: `"🎯 Ready to install Excel Taxonomy Extractor AddIn v1.X.X?"`
- install.ps1 Line ~513: `"🎉 INSTALLATION COMPLETE!" "...AddIn v1.X.X is ready to use"`

### 🚨 CRITICAL INSTALLER REQUIREMENTS:

**Frame Alignment**: All UI frames 79-character width, content uses `.PadRight(77)`
**Progress System**: 9 steps = 0%→100%, one `Update-ProgressDisplay` per step
**Terminology**: Always "Excel Taxonomy Extractor AddIn" (not "Cleaner")
**Registry Management**: Auto-remove old versions, prevent duplicates

**Color Scheme**: DarkCyan (progress), Green (prompts), Cyan (logo), Yellow (status), Red (errors)
**ASCII Logo**: Never modify user-maintained logo content

### 🔧 Testing Protocol for Each Version:
1. Clean install, upgrade test, same version test
2. Frame alignment, progress flow, registry cleanup
3. Terminology consistency verification

## Development Best Practices & Lessons Learned

### Key VBA Patterns
- **Type Definitions**: `ParsedCellData` for structured data passing
- **Method Injection**: `SetParsedData` for loose coupling
- **Graceful Degradation**: InputBox fallback if UserForm missing
- **Screen Updating Control**: Performance optimization during batch operations

### UI/UX Principles Applied
- **Context Awareness**: Show user's actual data, not generic examples
- **Progressive Disclosure**: Preview before action
- **Silent Operation**: No unnecessary confirmations
- **Immediate Feedback**: Instant extraction with visible results
- **Easy Reversal**: One-click undo system

### Error Handling Strategy
- **No Selection**: Prompt user to select cells
- **No Text Content**: Validate cells contain text
- **Insufficient Segments**: Process available segments, report results
- **Loop Protection**: Ensure all selected cells get processed

### Testing Approach
- Test with real taxonomy data, not simple examples
- Verify graceful handling of missing segments
- Test batch processing with mixed data types
- Validate undo functionality across scenarios

### Future Enhancement Opportunities
1. Configuration storage for user preferences
2. Custom delimiter support
3. Direct export capabilities (CSV/other formats)
4. Batch templates for predefined patterns
5. Advanced validation and content suggestions

### Code Organization Principles
- **Single Responsibility**: Each function has one clear purpose
- **Data Encapsulation**: Type definitions for complex structures
- **Error Boundary**: Centralized error handling prevents cascades
- **Performance Awareness**: Memory management and screen updating control

## Modern Distribution Architecture

### PowerShell Integration
- GitHub Releases API integration
- Native Excel AddIns folder installation
- Automatic security configuration
- Registry integration for auto-loading

### Ribbon Button Integration
- CustomUI XML embedded via Custom UI Editor
- IPG branding: "IPG Taxonomy Extractor" in "IPG Tools" group
- Callback functions: `RibbonTaxonomyExtractor`
- Professional UI that survives distribution

### Security & Compatibility
- Trusted location setup
- File unblocking
- Optimal Excel folder compatibility
- Works without admin rights


================================================
FILE: clsAppEvents.vb
================================================
' clsAppEvents - Application Event Handler for Modeless UserForm
' Part of IPG Mediabrands Taxonomy Extractor v1.6.0
' 
' This class module handles Excel application events to enable real-time
' UserForm updates when users change their cell selection while the 
' TaxonomyExtractorForm is open in modeless mode.
'
' IMPORTANT: Copy only this code into your class module - do NOT include
' any VERSION, BEGIN, END, or Attribute lines that appear in exported files.

Public WithEvents App As Application

' Event handler for worksheet selection changes
' Fires whenever user selects different cells while modeless form is open
Private Sub App_SheetSelectionChange(ByVal Sh As Object, ByVal Target As Range)
    On Error GoTo ErrorHandler
    
    ' Only process if our UserForm is visible and modeless
    If Not TaxonomyExtractorForm Is Nothing Then
        If TaxonomyExtractorForm.Visible Then
            ' Temporarily disable events to prevent recursive loops
            Application.EnableEvents = False
            
            ' Update the UserForm with new selection
            Call TaxonomyExtractorForm.UpdateForNewSelection(Target)
            
            ' Re-enable events
            Application.EnableEvents = True
        End If
    End If
    
    Exit Sub
    
ErrorHandler:
    ' Ensure events are re-enabled even if error occurs
    Application.EnableEvents = True
    
    ' Log error but don't show message box (would interrupt user workflow)
    Debug.Print "clsAppEvents.App_SheetSelectionChange Error: " & Err.Description
End Sub

' Event handler for workbook activation changes
' Helps maintain proper form behavior when switching between workbooks
Private Sub App_WorkbookActivate(ByVal Wb As Workbook)
    On Error GoTo ErrorHandler
    
    ' Ensure our UserForm remains accessible when switching workbooks
    If Not TaxonomyExtractorForm Is Nothing Then
        If TaxonomyExtractorForm.Visible Then
            ' Keep form on top and responsive
            TaxonomyExtractorForm.SetFocus
        End If
    End If
    
    Exit Sub
    
ErrorHandler:
    Debug.Print "clsAppEvents.App_WorkbookActivate Error: " & Err.Description
End Sub

' Event handler for application deactivation
' Manages form behavior when user switches to other applications
Private Sub App_WindowDeactivate(ByVal Wb As Workbook, ByVal Wn As Window)
    On Error GoTo ErrorHandler
    
    ' Optional: Could implement logic to handle Excel losing focus
    ' For now, just ensure events remain properly configured
    
    Exit Sub
    
ErrorHandler:
    Debug.Print "clsAppEvents.App_WindowDeactivate Error: " & Err.Description
End Sub

' Cleanup method to be called when shutting down event monitoring
Public Sub Cleanup()
    On Error Resume Next
    Set App = Nothing
End Sub


================================================
FILE: DEPLOYMENT_CHECKLIST.md
================================================
# Deployment Checklist - Excel Taxonomy Extractor v1.6.0

This checklist ensures proper deployment of the one-liner PowerShell installation system.

## 📋 Pre-Deployment Checklist

### 1. XLAM File Preparation
- [ ] XLAM file contains all VBA code from `TaxonomyExtractorModule.vb`
- [ ] UserForm created following `TaxonomyExtractorForm.vb` instructions  
- [ ] UserForm named exactly `TaxonomyExtractorForm`
- [ ] CustomUI ribbon XML embedded with IPG branding (see `RIBBON_SOLUTION.md`)
- [ ] Ribbon shows "IPG Taxonomy Extractor" button in "IPG Tools" group on Home tab
- [ ] Ribbon callback functions already included in VBA module (no manual addition needed)
- [ ] File tested on clean Excel installation
- [ ] File saved as `.xlam` format (not .xlsm)

### 2. Repository Structure
```
excel-taxonomy-cleaner/
├── install.ps1                     # ✅ Created - Main installation script
├── README.md                       # ✅ Updated - With one-liner installation
├── TaxonomyExtractorModule.vb      # ✅ Existing - Main VBA code
├── TaxonomyExtractorForm.vb        # ✅ Existing - UserForm instructions
├── RIBBON_SOLUTION.md              # ✅ Created - Complete ribbon guide
├── DEPLOYMENT_CHECKLIST.md         # ✅ This file
├── ADDON_INSTRUCTIONS.md           # ✅ Existing - Manual add-in guide
└── CLAUDE.md                       # ✅ Existing - Development docs
```

### 3. GitHub Repository Setup
- [ ] Repository exists: `henkisdabro/excel-taxonomy-cleaner`
- [ ] `install.ps1` committed to main branch
- [ ] Updated README.md committed
- [ ] All documentation files committed
- [ ] Repository is public (required for raw.githubusercontent.com access)

### 4. GitHub Release Creation
- [ ] Create new release (e.g., v1.6.0)
- [ ] Upload `TaxonomyExtractor.xlam` as release asset
- [ ] Verify asset name matches exactly: `TaxonomyExtractor.xlam`
- [ ] Release marked as "Latest release"
- [ ] Release description includes changelog

## 🚀 Deployment Steps

### Step 1: Upload XLAM to GitHub Release
```bash
# Create release and upload XLAM file
gh release create v1.6.0 TaxonomyExtractor.xlam --title "Excel Taxonomy Extractor v1.6.0" --notes "Professional VBA utility for extracting taxonomy segments with multi-step undo and enhanced UX"
```

### Step 2: Test Installation Script Locally
```powershell
# Test the installation process
irm "https://raw.githubusercontent.com/henkisdabro/excel-taxonomy-cleaner/main/install.ps1" | iex
```

### Step 3: Verify Download URL
Test that the GitHub Releases API returns the correct download URL:
```powershell
$release = Invoke-RestMethod "https://api.github.com/repos/henkisdabro/excel-taxonomy-cleaner/releases/latest"
$release.assets | Where-Object { $_.name -eq "TaxonomyExtractor.xlam" } | Select-Object browser_download_url
```

### Step 4: Test Complete Installation Flow
- [ ] Fresh Excel installation (or VM)
- [ ] Run PowerShell one-liner
- [ ] Verify XLAM downloads to Templates folder
- [ ] Verify file is unblocked
- [ ] Verify registry entry created
- [ ] Open Excel and check add-in loads
- [ ] Verify ribbon button appears
- [ ] Test functionality with sample data
- [ ] Test uninstall command

## 🔧 Configuration Verification

### PowerShell Script Configuration
Verify these values in `install.ps1`:
- [ ] `$RepoOwner = "henkisdabro"`
- [ ] `$RepoName = "excel-taxonomy-cleaner"`
- [ ] `$AddInName = "TaxonomyExtractor.xlam"`
- [ ] GitHub API URL correct
- [ ] Templates folder path correct: `$env:APPDATA\Microsoft\Templates`

### Registry Paths (Windows 11/Excel 2024)
- [ ] Add-in registration: `HKCU:\Software\Microsoft\Office\16.0\Excel\Options`
- [ ] Trusted locations: `HKCU:\Software\Microsoft\Office\16.0\Excel\Security\Trusted Locations`

## 🧪 Testing Matrix

### Test Environments
- [ ] Windows 11 + Excel 2024 (Office 365)
- [ ] Windows 11 + Excel 2021
- [ ] Windows 10 + Excel 365
- [ ] Clean Excel installation (no existing add-ins)
- [ ] Excel with existing add-ins (conflict testing)

### Test Scenarios
- [ ] **Fresh installation**: No prior version installed
- [ ] **Upgrade scenario**: Previous version exists
- [ ] **Reinstallation**: Same version already installed
- [ ] **Network restrictions**: Corporate firewall/proxy
- [ ] **Antivirus software**: Windows Defender + third-party AV
- [ ] **PowerShell execution policy**: Default restrictive settings

### Functional Testing
- [ ] Add-in loads automatically on Excel startup
- [ ] Ribbon button appears in correct location
- [ ] Button click launches TaxonomyExtractor function
- [ ] UserForm displays with correct data preview
- [ ] All 9 segment buttons work correctly
- [ ] Activation ID button works
- [ ] Undo functionality works
- [ ] Uninstall removes all components

## 📈 Success Metrics

### Installation Success Indicators
- [ ] PowerShell script completes without errors
- [ ] XLAM file downloaded to Templates folder
- [ ] File successfully unblocked
- [ ] Registry entries created
- [ ] Desktop instructions file created
- [ ] No Windows security warnings

### Runtime Success Indicators
- [ ] Excel loads add-in automatically
- [ ] "IPG Tools" group appears on Home tab with "IPG Taxonomy Extractor" button
- [ ] Button click responds immediately
- [ ] UserForm displays actual data preview
- [ ] Segment extraction works silently
- [ ] Undo system functions properly

## 🐛 Common Issues & Solutions

### PowerShell Execution Policy
**Issue**: Script won't run due to execution policy
**Solution**: Include in documentation:
```powershell
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
```

### GitHub API Rate Limiting
**Issue**: Too many requests to GitHub API
**Solution**: Script includes proper User-Agent header and error handling

### Antivirus False Positives
**Issue**: XLAM file flagged as suspicious
**Solution**: Include file hash verification and code signing information

### Excel Trust Issues
**Issue**: Add-in loads but ribbon doesn't appear
**Solution**: Script adds Templates folder to trusted locations as backup

## 📊 Monitoring & Analytics

### Track These Metrics
- [ ] PowerShell script download frequency (GitHub raw file requests)
- [ ] GitHub Release download counts
- [ ] Repository stars/forks as adoption indicator
- [ ] Issues opened related to installation problems

### Success Rate Monitoring
- [ ] Monitor GitHub Issues for installation problems
- [ ] Track success rate based on user feedback
- [ ] Document common installation failures
- [ ] Update script based on user issues

## 🔄 Update Process

### For Future Versions
1. [ ] Update version numbers in all files
2. [ ] Create new GitHub Release with updated XLAM
3. [ ] Update `install.ps1` if needed (usually not required)
4. [ ] Test installation of new version
5. [ ] Update documentation

### Hotfix Process
1. [ ] Fix issue in XLAM file
2. [ ] Create patch release (e.g., v1.6.1)
3. [ ] Upload fixed XLAM file
4. [ ] No script changes needed (auto-downloads latest)

## ✅ Final Deployment Verification

Before going live, verify:
- [ ] All checkboxes in this document completed
- [ ] Test installation successful on 3+ different systems
- [ ] Documentation is clear and complete
- [ ] One-liner command works from any PowerShell session
- [ ] Uninstall process works correctly
- [ ] No errors in PowerShell script execution
- [ ] All GitHub repository settings correct
- [ ] Release assets properly uploaded

## 🎯 Post-Deployment Tasks

### Immediate (0-24 hours)
- [ ] Monitor for initial user feedback
- [ ] Watch for GitHub Issues related to installation
- [ ] Test one-liner from multiple networks
- [ ] Document any issues that arise

### Short-term (1-7 days)
- [ ] Gather user feedback on installation experience
- [ ] Monitor download statistics
- [ ] Update documentation based on user questions
- [ ] Address any critical issues

### Long-term (1+ weeks)
- [ ] Plan next version improvements
- [ ] Consider additional distribution methods
- [ ] Evaluate need for code signing
- [ ] Document lessons learned

---

**Ready for deployment when all checkboxes are completed!** ✅


================================================
FILE: install.ps1
================================================
# Excel Taxonomy Extractor v1.6.0 - One-Click Installation Script
# Repository: https://github.com/henkisdabro/excel-taxonomy-cleaner
# Usage: 
#   Install: irm "https://raw.githubusercontent.com/henkisdabro/excel-taxonomy-cleaner/main/install.ps1" | iex

[CmdletBinding()]
param(
    [string]$Version = "latest"
)

# Configuration
$RepoOwner = "henkisdabro"
$RepoName = "excel-taxonomy-cleaner"
$AddInName = "ipg_taxonomy_extractor_addonv1.6.0.xlam"
$DisplayName = "Excel Taxonomy Extractor AddIn v1.6.0"

# Paths
$AddInsPath = "$env:APPDATA\Microsoft\AddIns"
$AddInPath = Join-Path $AddInsPath $AddInName
$TempPath = Join-Path $env:TEMP "taxonomy-extractor-install"

# Global variables for progress tracking
$Global:InstallSteps = @()
$Global:CurrentStep = 0
$Global:StartTime = Get-Date

function Initialize-ProgressTracker {
    $Global:InstallSteps = @(
        @{ Name = "Validating Environment"; Status = "pending"; Icon = "🔍"; Time = $null },
        @{ Name = "Fetching Latest Release"; Status = "pending"; Icon = "📡"; Time = $null },
        @{ Name = "Downloading AddIn"; Status = "pending"; Icon = "⬇️"; Time = $null },
        @{ Name = "Cleaning Old Versions"; Status = "pending"; Icon = "🧹"; Time = $null },
        @{ Name = "Registry Cleanup"; Status = "pending"; Icon = "🧼"; Time = $null },
        @{ Name = "Installing AddIn"; Status = "pending"; Icon = "📦"; Time = $null },
        @{ Name = "Configuring Security"; Status = "pending"; Icon = "🔐"; Time = $null },
        @{ Name = "Registry Registration"; Status = "pending"; Icon = "📝"; Time = $null },
        @{ Name = "Finalizing Setup"; Status = "pending"; Icon = "🎯"; Time = $null }
    )
}

function Write-ProgressBar {
    param([int]$Percent, [string]$Label = "", [string]$Color = "Green")
    
    $barWidth = 50
    $filled = [Math]::Floor($barWidth * $Percent / 100)
    $empty = $barWidth - $filled
    
    $bar = "█" * $filled + "░" * $empty
    $percentStr = "$Percent%".PadLeft(4)
    $barText = "[$bar] $percentStr $Label"
    
    Write-Host $barText.PadRight(77) -ForegroundColor $Color -NoNewline
}

function Update-StepStatus {
    param([int]$StepIndex, [string]$Status, [string]$Message = "")
    
    if ($StepIndex -lt $Global:InstallSteps.Count) {
        $Global:InstallSteps[$StepIndex].Status = $Status
        $Global:InstallSteps[$StepIndex].Time = (Get-Date) - $Global:StartTime
        
        if ($Status -eq "running") {
            $Global:CurrentStep = $StepIndex
        }
        
        Update-ProgressDisplay $Message
    }
}

function Show-Spinner {
    param([string]$Message = "Processing...")
    
    $spinChars = @("⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏")
    $counter = 0
    
    for ($i = 0; $i -lt 10; $i++) {
        Write-Host "`r  $($spinChars[$counter % $spinChars.Length]) $Message" -NoNewline -ForegroundColor Cyan
        Start-Sleep -Milliseconds 100
        $counter++
    }
    Write-Host ""
}

function Update-ProgressDisplay {
    param([string]$CurrentMessage = "")
    
    # Simple and reliable approach: just clear screen and redraw
    # This avoids cursor positioning issues that cause duplication
    Clear-Host
    
    # Header
    Write-Host "┌───────────────────────────────────────────────────────────────────────────────┐" -ForegroundColor White
    Write-Host "│" -ForegroundColor White -NoNewline
    Write-Host "  📊 INSTALLATION PROGRESS".PadRight(79) -ForegroundColor White -NoNewline
    Write-Host "│" -ForegroundColor White
    Write-Host "├───────────────────────────────────────────────────────────────────────────────┤" -ForegroundColor White
    
    # Progress steps
    for ($i = 0; $i -lt $Global:InstallSteps.Count; $i++) {
        $step = $Global:InstallSteps[$i]
        $statusIcon = switch ($step.Status) {
            "completed" { "✅" }
            "running" { "⚡" }
            "failed" { "❌" }
            default { "⏳" }
        }
        
        $color = switch ($step.Status) {
            "completed" { "Green" }
            "running" { "Yellow" }
            "failed" { "Red" }
            default { "Gray" }
        }
        
        $timeStr = if ($step.Time) { " ({0:F1}s)" -f $step.Time.TotalSeconds } else { "" }
        $mainText = "  $statusIcon $($step.Icon) $($step.Name)"
        
        # Calculate total length and ensure proper alignment
        $totalTextLength = $mainText.Length + $timeStr.Length
        $paddingNeeded = [Math]::Max(0, 78 - $totalTextLength)
        
        Write-Host "│" -ForegroundColor White -NoNewline
        Write-Host $mainText -ForegroundColor $color -NoNewline
        if ($step.Time) {
            Write-Host $timeStr -ForegroundColor Gray -NoNewline
        }
        Write-Host (" " * $paddingNeeded) -NoNewline
        Write-Host "│" -ForegroundColor White
    }
    
    # Overall progress bar - calculate based on current step being worked on
    $completedSteps = ($Global:InstallSteps | Where-Object { $_.Status -eq "completed" }).Count
    $currentRunningStep = -1
    
    # Find the currently running step
    for ($i = 0; $i -lt $Global:InstallSteps.Count; $i++) {
        if ($Global:InstallSteps[$i].Status -eq "running") {
            $currentRunningStep = $i
            break
        }
    }
    
    # Progress calculation: 0%, 11%, 22%, 33%, 44%, 55%, 66%, 77%, 88%, 100%
    if ($completedSteps -eq $Global:InstallSteps.Count) {
        # All steps completed
        $overallPercent = 100
    } elseif ($currentRunningStep -ge 0) {
        # A step is currently running - show progress for that step
        $overallPercent = $currentRunningStep * 11
    } else {
        # No steps running, show progress based on completed steps
        $overallPercent = $completedSteps * 11
    }
    
    Write-Host "├───────────────────────────────────────────────────────────────────────────────┤" -ForegroundColor White
    Write-Host "│" -ForegroundColor White -NoNewline
    Write-Host "  " -NoNewline
    Write-ProgressBar $overallPercent "Overall Progress" "Cyan"
    Write-Host "│" -ForegroundColor White
    
    # Current action
    if ($CurrentMessage) {
        Write-Host "│" -ForegroundColor White -NoNewline
        Write-Host "  🔄 $CurrentMessage".PadRight(79) -ForegroundColor Yellow -NoNewline
        Write-Host "│" -ForegroundColor White
    }
    
    Write-Host "└───────────────────────────────────────────────────────────────────────────────┘" -ForegroundColor White
}

function Write-Status {
    param([string]$Message, [string]$Color = "Green")
    Write-Host "  🔄 $Message" -ForegroundColor $Color
}

function Write-Error {
    param([string]$Message)
    Write-Host "  ❌ ERROR: $Message" -ForegroundColor Red
}

function Write-Success {
    param([string]$Message)
    Write-Host "  ✅ $Message" -ForegroundColor Green
}

function Write-Logo {
    $logo = @"
::::::::::     :::::::::::::::::::::::        xxxxxxxxxxxxxxx          
::::::::::     ::::::::::::::::::::::::::  xxxxxxxxxxxxxxxxxxxxx       
::::::::::     ::::::::::::::::::::::::::x&xxxxxxxxxxxxxxxxxxxxxxx     
::::::::::     ::::::::::::::::::::::::;&&&&xxxxxxxxxxxxxxxxxxxxx      
::::::::::     :::::::::::::::::::::::X&&&&&&xxxxxxxxxxxxxxxxxx        
::::::::::     ::::::::::         :::X&&&&&&&xxxxx      xxxx           
::::::::::     ::::::::::          :x&&&&&&&&Xxx                       
::::::::::     ::::::::::          $&&&&&&&&&&X                        
::::::::::     ::::::::::          &&&&&&&&&&&       xxxxxxxxxxxxxxxxxx
::::::::::     ::::::::::         :;&&&&&&&&&&       xxxxxxxxxxxxxxxxxx
::::::::::     ::::::::::::::::::::;&&&&&&&&&x       xxxxxxxxxxxxxxxxxx
::::::::::     ::::::::::::::::::::;$&&&&&&Xxxx      xxxxxxxxxxxxxxxxxx
::::::::::     :::::::::::::::::::::;&&&&&xxxxxx      xxxxxxxxxxxxxxxxX
::::::::::     ::::::::::::::::::::::x&&xxxxxxxxxxx     xxxxxxxxxxxxxx 
::::::::::     :::::::::::::::::::::  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  
::::::::::     ::::::::::              xxxxxxxxxxxxxxxxxxxxxxxxxxxxx   
::::::::::     ::::::::::                xxxxxxxxxxxxxxxxxxxxxxxxx     
::::::::::     ::::::::::                  xxxxxxxxxxxxxxxxxxxxx       
::::::::::     ::::::::::                     xxxxxxxxxxxxxxX  

🏢 IPG MEDIABRANDS TAXONOMY EXTRACTOR ADDIN FOR EXCEL v1.6.0 🏢

"@
    Write-Host $logo -ForegroundColor Cyan
}

function Write-Header {
    param([string]$Title, [string]$Subtitle = "")
    
    Write-Host ""
    Write-Host "┌───────────────────────────────────────────────────────────────────────────────┐" -ForegroundColor White
    Write-Host "│" -ForegroundColor White -NoNewline
    Write-Host ("  " + $Title).PadRight(79) -ForegroundColor White -NoNewline
    Write-Host "│" -ForegroundColor White
    
    if ($Subtitle) {
        Write-Host "│" -ForegroundColor White -NoNewline
        Write-Host ("  " + $Subtitle).PadRight(79) -ForegroundColor Gray -NoNewline
        Write-Host "│" -ForegroundColor White
    }
    
    Write-Host "└───────────────────────────────────────────────────────────────────────────────┘" -ForegroundColor White
    Write-Host ""
}

function Remove-OrphanedAddinRegistryKeys {
    param(
        [string]$CurrentAddInName
    )
    
    try {
        Write-Status "🧼 Cleaning orphaned AddIn registry keys..." "Yellow"
        $regPath = "HKCU:\Software\Microsoft\Office\16.0\Excel\Options"
        
        # Ensure registry path exists
        if (-not (Test-Path $regPath)) {
            Write-Status "Excel registry path not found - skipping registry cleanup" "Yellow"
            return
        }
        
        $removedCount = 0
        $counter = 0
        
        # Check OPEN and OPEN1, OPEN2, etc. up to OPEN50
        do {
            $keyName = if ($counter -eq 0) { "OPEN" } else { "OPEN$counter" }
            
            try {
                $regValue = Get-ItemProperty -Path $regPath -Name $keyName -ErrorAction SilentlyContinue
                
                if ($regValue -and $regValue.$keyName) {
                    $registryValue = $regValue.$keyName
                    $shouldDelete = $false
                    
                    # Remove quotes if present and extract filename from registry value
                    $cleanRegistryValue = $registryValue.Trim('"')
                    $registryFileName = [System.IO.Path]::GetFileName($cleanRegistryValue)
                    
                    Write-Status "Checking registry key '$keyName' with value: $registryValue" "Gray"
                    Write-Status "  Extracted filename: $registryFileName" "Gray"
                    
                    # Check if registry value contains our AddIn patterns and is not the current version
                    if (($registryFileName -like "ipg_taxonomy_extractor_addon*") -and 
                        ($registryFileName -ne $CurrentAddInName)) {
                        $shouldDelete = $true
                        Write-Status "🔍 Found old AddIn registry key '$keyName' referencing: $registryFileName" "Yellow"
                    }
                    elseif (($registryFileName -like "TaxonomyExtractor*") -and 
                            ($registryFileName -ne $CurrentAddInName)) {
                        $shouldDelete = $true
                        Write-Status "🔍 Found old AddIn registry key '$keyName' referencing: $registryFileName" "Yellow"
                    }
                    elseif (($registryFileName -like "taxonomy_extractor*") -and 
                            ($registryFileName -ne $CurrentAddInName)) {
                        $shouldDelete = $true
                        Write-Status "🔍 Found old AddIn registry key '$keyName' referencing: $registryFileName" "Yellow"
                    }
                    
                    # Remove the old registry key
                    if ($shouldDelete) {
                        Remove-ItemProperty -Path $regPath -Name $keyName -ErrorAction Stop
                        Write-Success "🗑️ Removed old registry key: $keyName (was: $registryFileName)"
                        $removedCount++
                    }
                }
            }
            catch {
                Write-Status "Failed to process registry key '$keyName': $($_.Exception.Message)" "Red"
            }
            
            $counter++
        } while ($counter -lt 50)
        
        if ($removedCount -gt 0) {
            Write-Success "Cleaned $removedCount old registry entries"
        } else {
            Write-Status "No old registry entries found to clean"
        }
    }
    catch {
        Write-Status "Registry cleanup failed: $($_.Exception.Message)" "Red"
        # Don't throw - registry cleanup failure shouldn't stop installation
    }
}

function Test-ExcelInstalled {
    try {
        $excel = New-Object -ComObject Excel.Application -ErrorAction Stop
        $excel.Quit()
        [System.Runtime.Interopservices.Marshal]::ReleaseComObject($excel) | Out-Null
        return $true
    }
    catch {
        return $false
    }
}

function Get-LatestReleaseUrl {
    try {
        Write-Status "Fetching latest release information..."
        $apiUrl = "https://api.github.com/repos/$RepoOwner/$RepoName/releases/latest"
        $release = Invoke-RestMethod -Uri $apiUrl -Headers @{"User-Agent" = "PowerShell-ExcelTaxonomyInstaller"}
        
        $asset = $release.assets | Where-Object { $_.name -eq $AddInName }
        if (-not $asset) {
            throw "AddIn file '$AddInName' not found in latest release"
        }
        
        return @{
            DownloadUrl = $asset.browser_download_url
            Version = $release.tag_name
            ReleaseDate = $release.published_at
        }
    }
    catch {
        Write-Error "Failed to fetch release information: $($_.Exception.Message)"
        throw
    }
}

function Install-AddIn {
    try {
        # Initialize the progress tracker
        Initialize-ProgressTracker
        Update-ProgressDisplay
        Start-Sleep -Milliseconds 500
        
        # Step 1: Verify Excel is installed
        Update-StepStatus 0 "running" "Checking Excel installation..."
        Show-Spinner "Validating Excel environment"
        
        if (-not (Test-ExcelInstalled)) {
            Update-StepStatus 0 "failed"
            throw "Microsoft Excel is not installed or cannot be accessed"
        }
        Update-StepStatus 0 "completed"

        # Step 2: Get latest release
        Update-StepStatus 1 "running" "Fetching release information from GitHub..."
        Show-Spinner "Contacting GitHub API"
        $releaseInfo = Get-LatestReleaseUrl
        Update-StepStatus 1 "completed"
        Write-Status "Found version: $($releaseInfo.Version)" "Cyan"

        # Step 3: Download AddIn
        Update-StepStatus 2 "running" "Downloading latest AddIn file..."
        
        # Create temp directory
        if (Test-Path $TempPath) {
            Remove-Item $TempPath -Recurse -Force
        }
        New-Item -ItemType Directory -Path $TempPath -Force | Out-Null

        $tempAddInPath = Join-Path $TempPath $AddInName
        Show-Spinner "Downloading from GitHub releases"
        Invoke-WebRequest -Uri $releaseInfo.DownloadUrl -OutFile $tempAddInPath -UseBasicParsing

        # Verify download
        if (-not (Test-Path $tempAddInPath)) {
            Update-StepStatus 2 "failed"
            throw "Failed to download AddIn file"
        }
        Update-StepStatus 2 "completed"

        # Ensure AddIns directory exists
        if (-not (Test-Path $AddInsPath)) {
            New-Item -ItemType Directory -Path $AddInsPath -Force | Out-Null
        }

        # Step 4: Remove old versions before installing new one
        Update-StepStatus 3 "running" "Scanning for old versions to remove..."
        Show-Spinner "Analyzing installed AddIns"
        
        # Get all XLAM files in the AddIns directory
        $allXlamFiles = Get-ChildItem -Path $AddInsPath -Filter "*.xlam" -ErrorAction SilentlyContinue
        
        foreach ($file in $allXlamFiles) {
            $fileName = $file.Name
            $shouldDelete = $false
            
            # Check if it matches our taxonomy extractor patterns
            if ($fileName -like "ipg_taxonomy_extractor_addon*" -or 
                $fileName -like "TaxonomyExtractor*" -or 
                $fileName -like "taxonomy_extractor*") {
                $shouldDelete = $true
            }
            
            # Skip the current version we're about to install
            if ($fileName -eq $AddInName) {
                $shouldDelete = $false
            }
            
            # Delete old versions
            if ($shouldDelete) {
                try {
                    Remove-Item $file.FullName -Force -ErrorAction Stop
                    Write-Status "🗑️ Removed old version: $fileName" "Yellow"
                } catch {
                    Write-Status "Failed to remove $fileName`: $($_.Exception.Message)" "Red"
                }
            }
        }
        
        Update-StepStatus 3 "completed"
        
        # Step 5: Clean orphaned registry keys
        Update-StepStatus 4 "running" "Cleaning registry entries..."
        Show-Spinner "Scanning Windows registry"
        Remove-OrphanedAddinRegistryKeys -CurrentAddInName $AddInName
        Update-StepStatus 4 "completed"

        # Step 6: Install to AddIns folder
        Update-StepStatus 5 "running" "Installing AddIn to Excel folder..."
        Show-Spinner "Copying files to AddIns directory"
        Copy-Item $tempAddInPath -Destination $AddInPath -Force

        # Verify installation was successful
        if (-not (Test-Path $AddInPath)) {
            Update-StepStatus 5 "failed"
            throw "Failed to copy AddIn file to destination"
        }
        Update-StepStatus 5 "completed"

        # Step 7: Configure security
        Update-StepStatus 6 "running" "Configuring security permissions..."
        Show-Spinner "Unblocking files and setting permissions"
        Unblock-File -Path $AddInPath -ErrorAction SilentlyContinue
        Update-StepStatus 6 "completed"

        # Step 8: Register AddIn in Excel registry
        Update-StepStatus 7 "running" "Registering with Excel..."
        Show-Spinner "Creating registry entries"
        $regPath = "HKCU:\Software\Microsoft\Office\16.0\Excel\Options"
        
        # Ensure registry path exists
        if (-not (Test-Path $regPath)) {
            Write-Status "Creating Excel registry path..."
            New-Item -Path $regPath -Force | Out-Null
        }
        
        # Check if current version is already registered
        $currentVersionRegistered = $false
        $existingKeyName = ""
        $counter = 0
        
        # First pass: check if current version already exists
        do {
            $keyName = if ($counter -eq 0) { "OPEN" } else { "OPEN$counter" }
            $existingValue = Get-ItemProperty -Path $regPath -Name $keyName -ErrorAction SilentlyContinue
            
            if ($existingValue -and $existingValue.$keyName) {
                $existingRegistryValue = $existingValue.$keyName
                $cleanExistingValue = $existingRegistryValue.Trim('"')
                $existingFileName = [System.IO.Path]::GetFileName($cleanExistingValue)
                
                if ($existingFileName -eq $AddInName) {
                    $currentVersionRegistered = $true
                    $existingKeyName = $keyName
                    Write-Status "Current version already registered as '$keyName'" "Green"
                    break
                }
            }
            $counter++
        } while ($counter -lt 50)
        
        # If not already registered, find next available slot
        if (-not $currentVersionRegistered) {
            $openNumber = ""
            $counter = 0
            do {
                $keyName = if ($counter -eq 0) { "OPEN" } else { "OPEN$counter" }
                $existingValue = Get-ItemProperty -Path $regPath -Name $keyName -ErrorAction SilentlyContinue
                if (-not $existingValue) {
                    $openNumber = $keyName
                    break
                }
                $counter++
            } while ($counter -lt 50)

            if ($openNumber) {
                # Use filename-only format with quotes as required by Excel
                $registryValue = "`"$AddInName`""
                New-ItemProperty -Path $regPath -Name $openNumber -Value $registryValue -PropertyType String -Force | Out-Null
                Write-Success "Registered AddIn as '$openNumber' with value: $registryValue"
            } else {
                Write-Status "Warning: Could not find available OPEN slot in registry (checked OPEN0-OPEN49)" "Yellow"
            }
        }
        Update-StepStatus 7 "completed"

        # Step 9: Finalize setup
        Update-StepStatus 8 "running" "Finalizing installation..."
        Show-Spinner "Setting up trusted locations and creating shortcuts"
        $trustRegPath = "HKCU:\Software\Microsoft\Office\16.0\Excel\Security\Trusted Locations"
        $locationPath = "$trustRegPath\Location99"
        
        if (-not (Test-Path $locationPath)) {
            New-Item -Path $locationPath -Force | Out-Null
        }
        
        Set-ItemProperty -Path $locationPath -Name "Path" -Value "$AddInsPath\"
        Set-ItemProperty -Path $locationPath -Name "AllowSubFolders" -Value 1
        Set-ItemProperty -Path $locationPath -Name "Description" -Value "Excel AddIns (Auto-trusted by Taxonomy Extractor installer)"


        # Cleanup
        Remove-Item $TempPath -Recurse -Force -ErrorAction SilentlyContinue
        Update-StepStatus 8 "completed"

        # Brief pause to show 100% completion
        Start-Sleep -Milliseconds 1000
        
        Write-Header "🎉 INSTALLATION COMPLETE!" "Open Excel and find the IPG Taxonomy Extractor button in the Home tab"
        
        Write-Host "📂 AddIn location: " -ForegroundColor Gray -NoNewline
        Write-Host "$AddInPath" -ForegroundColor Cyan
        Write-Host "🎯 IPG Taxonomy Extractor button will appear in IPG Tools group on Home tab" -ForegroundColor Gray
        Write-Host ""
        Write-Host "🗑️  " -ForegroundColor Red -NoNewline
        Write-Host "TO UNINSTALL:" -ForegroundColor Yellow
        Write-Host "   Go to File → Options → Add-ins → Excel Add-ins → Go → Uncheck the AddIn" -ForegroundColor Gray
        
        Write-Host ""

    }
    catch {
        Write-Error $_.Exception.Message
        Write-Host ""
        Write-Host "Installation failed. Please try again or check:" -ForegroundColor Yellow
        Write-Host "• Internet connection" -ForegroundColor White
        Write-Host "• Excel installation" -ForegroundColor White
        Write-Host "• PowerShell execution policy (try: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser)" -ForegroundColor White
        exit 1
    }
}


# Main execution
try {
    Clear-Host
    
    # Startup sequence with animation
    Write-Host "⚡ " -ForegroundColor Yellow -NoNewline
    Write-Host "Initializing IPG Taxonomy Extractor AddIn Installer..." -ForegroundColor White
    Show-Spinner "Loading installer components"
    
    Clear-Host
    Write-Logo
    Write-Header "🚀 AUTOMATED INSTALLER" "One-click installation with smart upgrade handling"
    
    Write-Host "📍 Repository: " -ForegroundColor Gray -NoNewline
    Write-Host "https://github.com/$RepoOwner/$RepoName" -ForegroundColor Cyan
    Write-Host ""
    
    # Interactive prompt
    Write-Host "┌───────────────────────────────────────────────────────────────────────────────┐" -ForegroundColor White
    Write-Host "│" -ForegroundColor White -NoNewline
    Write-Host "  🎯 Ready to install Excel Taxonomy Extractor AddIn v1.6.0?".PadRight(79) -ForegroundColor White -NoNewline
    Write-Host "│" -ForegroundColor White
    Write-Host "│" -ForegroundColor White -NoNewline
    Write-Host "  📦 This will automatically download, install, and configure the AddIn".PadRight(79) -ForegroundColor Gray -NoNewline
    Write-Host "│" -ForegroundColor White
    Write-Host "└───────────────────────────────────────────────────────────────────────────────┘" -ForegroundColor White
    Write-Host ""
    
    Write-Host "Press " -ForegroundColor Gray -NoNewline
    Write-Host "ENTER" -ForegroundColor Yellow -NoNewline
    Write-Host " to continue or " -ForegroundColor Gray -NoNewline
    Write-Host "CTRL+C" -ForegroundColor Red -NoNewline
    Write-Host " to cancel..." -ForegroundColor Gray
    Read-Host
    
    Clear-Host
    Write-Logo

    Install-AddIn
}
catch {
    Write-Host ""
    Write-Host "💥 INSTALLATION FAILED" -ForegroundColor Red -BackgroundColor Black
    Write-Error "Script execution failed: $($_.Exception.Message)"
    Write-Host ""
    Write-Host "📞 Need help? Create an issue at: https://github.com/$RepoOwner/$RepoName/issues" -ForegroundColor Yellow
    exit 1
}


================================================
FILE: RIBBON_SOLUTION.md
================================================
# Excel Add-in Ribbon Solution - IPG Taxonomy Extractor

This document provides the complete solution for creating the **IPG Taxonomy Extractor** ribbon button that survives XLAM distribution and appears in the IPG Tools group on Excel's Home tab.

## Problem Analysis

XLAM add-ins work perfectly with VBA macros, but ribbon buttons disappear during distribution. This is solved by embedding CustomUI XML directly into the XLAM file structure using the Office RibbonX Editor.

## ✅ **Working Solution: Office RibbonX Editor**

This is the **proven method that works** for embedding ribbon buttons in XLAM files.

### Step 1: Download Office RibbonX Editor

1. **Download** from: https://github.com/fernandreu/office-ribbonx-editor/releases
2. **Install** the Office RibbonX Editor application
3. **This is the tool that actually works** for embedding ribbon buttons in XLAM files

### Step 2: Open XLAM in Office RibbonX Editor

1. **Launch** Office RibbonX Editor
2. **Open** your `ipg_taxonomy_extractor_addonvX.Y.Z.xlam` file in the editor
3. **Insert** → Office 2010+ Custom UI Part
4. **Replace** the default XML with this IPG-branded CustomUI:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<customUI xmlns="http://schemas.microsoft.com/office/2009/07/customui">
  <ribbon>
    <tabs>
      <tab idMso="TabHome">
        <group id="IPGToolsGroup" 
               label="IPG Tools" 
               insertAfterMso="GroupEditingExcel">
          <button id="IPGTaxonomyExtractorButton" 
                  imageMso="FontColorPicker"
                  size="large"
                  label="IPG Taxonomy Extractor"
                  screentip="IPG Taxonomy Extractor"
                  supertip="Extract specific segments from pipe-delimited IPG taxonomy data. Features 9 segment buttons plus activation ID extraction with modeless operation."
                  onAction="TaxonomyExtractorModule.RibbonTaxonomyExtractor" />
        </group>
      </tab>
    </tabs>
  </ribbon>
</customUI>
```

**Alternative icon options with letter-based imagery:**
- `imageMso="FontColorPicker"` - "A" with color picker (recommended)
- `imageMso="FontDialog"` - Font dialog icon with "Aa"
- `imageMso="AutoSumAlpha"` - Alpha symbol
- `imageMso="TextEffectsGallery"` - Stylized "A"
- `imageMso="CharacterSpacing"` - Text formatting icon
- `imageMso="Font"` - Simple font icon

### Step 3: Validate and Save

1. **Validate** the XML using the editor's "Validate" button
2. **Ensure no errors** - any XML errors will prevent the ribbon from loading
3. **Save** the file - this embeds the CustomUI XML into your XLAM structure
4. **Close** the Office RibbonX Editor

### Step 4: Verify VBA Module Contains Ribbon Callbacks

The `TaxonomyExtractorModule.vb` file already includes the required ribbon callback functions:

- ✅ **`RibbonTaxonomyExtractor`** - Called when the IPG Taxonomy Extractor button is clicked
- ✅ **`RibbonOnLoad`** - Optional callback for ribbon initialization  
- ✅ **`myRibbon`** - Global variable to hold ribbon reference

**No additional VBA code needed** - the callbacks are already integrated in the module!

## ✅ **Result**

After completing these steps:

1. **Your XLAM file** now contains embedded CustomUI XML
2. **The ribbon button** will appear automatically when the add-in loads
3. **IPG Tools group** will be visible on Excel's Home tab
4. **IPG Taxonomy Extractor button** will launch your tool
5. **Distribution** via PowerShell installer will preserve the ribbon

## 🎯 **Final Distribution**

Once your XLAM file contains the embedded ribbon, follow the Developer instructions in README.md for details on how to deploy and distribute the file.


================================================
FILE: TaxonomyExtractorForm.vb
================================================
'================================================================================
' EXCEL TAXONOMY EXTRACTOR - UserForm Code (TaxonomyExtractorForm)
'================================================================================
' 
' This file contains the VBA code for the working UserForm with 9 segment buttons + Activation ID button.
' This is the code that should be placed in your UserForm named "TaxonomyExtractorForm"

' Windows API functions for screen metrics (must be at module level)
#If VBA7 Then
    Private Declare PtrSafe Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
#Else
    Private Declare Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
#End If
'
' USERFORM SETUP (Already completed if your form is working):
' ==========================================================
' 
' UserForm Name: TaxonomyExtractorForm
' UserForm Properties:
'    - Width: 480
'    - Height: 320
'    - Caption: "Taxonomy Extractor - Select Segment"
'
' VERSION MANAGEMENT:
' ===================
' The UserForm_Initialize() code below sets the title to include version number (v1.1.0).
' IMPORTANT: Increment version number on each significant code update:
'   - v1.0.0: Initial release with 9 buttons + Activation ID
'   - v1.1.0: Added smart data preview and dynamic button captions
'   - v1.2.0: Enhanced undo functionality
'   - v1.6.0: Multi-step undo system with professional UX enhancements
' This helps track which version users are running in their Excel environment.
'
' CONTROLS (MUST be named exactly as shown):
' ===========================================
' 
' REQUIRED CONTROLS FOR SMART INTERFACE:
' 
' 1. INSTRUCTION LABEL (for data preview):
'    - Control Type: Label
'    - Name: lblInstructions
'    - Caption: "Select cells and click segment button"
'    - Position: Top of form (X: 12, Y: 12)
'    - Size: Width: 450, Height: 24
'    - Font: Calibri, 10pt
'    - Important: This label will show truncated data preview automatically
'
' 2. CELL COUNT LABEL (optional - shows number of selected cells):
'    - Control Type: Label
'    - Name: lblCellCount
'    - Caption: "Processing: 1 cells"
'    - Position: Below instructions (X: 12, Y: 36)
'    - Size: Width: 200, Height: 18
'    - Font: Calibri, 9pt
'    - Important: Access via cellData.SelectedCellCount
'
' 3. SEGMENT BUTTONS (9 buttons for segments 1-9):
'    - Control Type: CommandButton
'    - Names: btn1, btn2, btn3, btn4, btn5, btn6, btn7, btn8, btn9
'    - Default Captions: "Segment 1", "Segment 2", etc.
'    - Note: Captions will update automatically to show segment previews
'    - Suggested Layout: 3 rows x 3 columns
'      Row 1: btn1, btn2, btn3 (Y: 50)
'      Row 2: btn4, btn5, btn6 (Y: 90)
'      Row 3: btn7, btn8, btn9 (Y: 130)
'    - Size: Width: 140, Height: 30
'    - Spacing: X positions: 12, 164, 316
'
' 4. ACTIVATION ID BUTTON:
'    - Control Type: CommandButton
'    - Name: btnActivationID
'    - Default Caption: "Activation ID"
'    - Note: Caption will update to show "ID: [preview]"
'    - Position: X: 12, Y: 180
'    - Size: Width: 140, Height: 30
'
' 5. TARGETING ACRONYM CLEAN CONTROLS (overlaid on Segment 1 button):
'    - Control Type: CommandButton
'    - Name: TargetingAcronymCleanButton
'    - Caption: "Trim ^ABC^" (dynamically updated to show actual pattern)
'    - Position: Same as btn1 (overlaid on top)
'    - Size: Same as btn1
'    - Visible: Only when no pipes present AND caret pattern found
'    - Note: Removes text in format ^any_characters^ with optional trailing space
'    
'    - Control Type: Label (optional companion label)
'    - Name: AcronymCleanLabel
'    - Caption: Any descriptive text you want
'    - Position: Near TargetingAcronymCleanButton
'    - Visible: Same logic as button (only when targeting pattern detected)
'
' 6. ACTION BUTTONS:
'    - Control Type: CommandButton (2 buttons)
'    - Names: btnUndo, btnClose
'    - Captions: "Undo Last", "Close"
'    - Position: X: 12, Y: 220 (btnUndo), X: 240, Y: 220 (btnClose)
'    - Size: Width: 68, Height: 30
'    - Undo Button: Dynamically enabled/disabled with operation count (e.g., "Undo Last (3)")
'
' 7. UNDO CAPACITY WARNING LABEL:
'    - Control Type: Label
'    - Name: lblUndoWarning
'    - Caption: "⚠️ Undo limit reached (10/10). Oldest operations will be removed."
'    - Position: X: 12, Y: 252 (below Undo button)
'    - Size: Width: 350, Height: 20
'    - Font: 8pt, ForeColor: RGB(200, 100, 0) (orange warning color)
'    - Visible: Only when UndoOperationCount = 10
'
' LAYOUT SUMMARY:
' - Form dimensions: 480 x 280
' - lblInstructions shows: "Selected: [complete original text - no truncation]"
' - Segment buttons show: "1: [12 chars]", "2: [12 chars]", etc. (or "N/A" if missing)
' - ID button shows: "ID: [full activation ID]" (or "ID: N/A" if missing)
' - All previews update automatically when UserForm opens
'
' VBA CODE FOR THE USERFORM:
' ==========================
' After creating all controls above, copy and paste this code into the UserForm module (double-click TaxonomyExtractorForm):
' 
' IMPORTANT: The code below expects the exact control names listed above.
' If lblInstructions doesn't exist, the line lblInstructions.Caption will cause an error.
' Make sure all controls are created and named correctly before adding this code.

Private cellData As ParsedCellData

Public Sub SetParsedData(parsedData As ParsedCellData)
    cellData = parsedData
    
    ' DEBUG: Show what data was received
    Debug.Print "SetParsedData called with:"
    Debug.Print "  Original: " & cellData.OriginalText
    Debug.Print "  Truncated: " & cellData.TruncatedDisplay
    Debug.Print "  Segment1: " & cellData.Segment1
    Debug.Print "  Segment2: " & cellData.Segment2
    Debug.Print "  Segment3: " & cellData.Segment3
    Debug.Print "  ActivationID: " & cellData.ActivationID
    
    ' Update the interface immediately after receiving data
    UpdateInterface
End Sub

Private Sub UserForm_Initialize()
    Me.Caption = "IPG Mediabrands Taxonomy Extractor v1.6.0"
    
    ' DEBUG: Check if cellData has been populated
    Debug.Print "UserForm_Initialize called"
    Debug.Print "  cellData.OriginalText length: " & Len(cellData.OriginalText)
    
    ' Apply simple, reliable positioning - center within Excel window
    ApplyOptimalPositioning
    
    ' Note: SetParsedData will handle interface updates
    ' Don't try to update interface here as cellData may not be set yet
End Sub

Private Sub ApplyOptimalPositioning()
    ' Center the form within Excel's main window on the correct monitor
    ' Respects the UserForm's design-time Width and Height properties
    ' Includes bounds checking to prevent off-screen positioning
    
    On Error GoTo CenterOnScreen
    
    ' Get Excel application window position and size (this is the main Excel window)
    Dim excelLeft As Long, excelTop As Long, excelWidth As Long, excelHeight As Long
    excelLeft = Application.Left
    excelTop = Application.Top
    excelWidth = Application.Width
    excelHeight = Application.Height
    
    ' Get the form's design-time dimensions (don't override them)
    Dim formWidth As Long, formHeight As Long
    formWidth = Me.Width
    formHeight = Me.Height
    
    ' Calculate center position within Excel window
    Dim centerLeft As Long, centerTop As Long
    centerLeft = excelLeft + (excelWidth - formWidth) / 2
    centerTop = excelTop + (excelHeight - formHeight) / 2
    
    ' Get system metrics for bounds checking
    Dim screenWidth As Long, screenHeight As Long
    screenWidth = GetSystemMetrics(0)  ' SM_CXSCREEN - primary monitor width
    screenHeight = GetSystemMetrics(1) ' SM_CYSCREEN - primary monitor height
    
    ' For multi-monitor setups, we need virtual screen dimensions
    Dim virtualLeft As Long, virtualTop As Long, virtualWidth As Long, virtualHeight As Long
    virtualLeft = GetSystemMetrics(76)   ' SM_XVIRTUALSCREEN
    virtualTop = GetSystemMetrics(77)    ' SM_YVIRTUALSCREEN  
    virtualWidth = GetSystemMetrics(78)  ' SM_CXVIRTUALSCREEN
    virtualHeight = GetSystemMetrics(79) ' SM_CYVIRTUALSCREEN
    
    ' If virtual screen metrics failed, use primary screen
    If virtualWidth = 0 Or virtualHeight = 0 Then
        virtualLeft = 0
        virtualTop = 0
        virtualWidth = screenWidth
        virtualHeight = screenHeight
    End If
    
    ' Bounds checking to ensure window stays within virtual screen bounds
    Dim minMargin As Long
    minMargin = 50  ' Minimum distance from screen edges
    
    ' Ensure the window stays within the virtual screen bounds
    If centerLeft < virtualLeft + minMargin Then
        centerLeft = virtualLeft + minMargin
    ElseIf centerLeft + formWidth > virtualLeft + virtualWidth - minMargin Then
        centerLeft = virtualLeft + virtualWidth - formWidth - minMargin
    End If
    
    If centerTop < virtualTop + minMargin Then
        centerTop = virtualTop + minMargin
    ElseIf centerTop + formHeight > virtualTop + virtualHeight - minMargin Then
        centerTop = virtualTop + virtualHeight - formHeight - minMargin
    End If
    
    ' Final sanity check - if position is still invalid, fall back
    If centerLeft < virtualLeft Or centerTop < virtualTop Or _
       centerLeft + formWidth > virtualLeft + virtualWidth Or _
       centerTop + formHeight > virtualTop + virtualHeight Then
        GoTo CenterOnScreen
    End If
    
    ' Apply the calculated position
    Me.StartUpPosition = 0  ' Manual positioning
    Me.Left = centerLeft
    Me.Top = centerTop
    
    Debug.Print "ApplyOptimalPositioning: Positioned at (" & centerLeft & ", " & centerTop & ") within Excel window (" & excelLeft & ", " & excelTop & ", " & excelWidth & "x" & excelHeight & ") on virtual screen (" & virtualLeft & ", " & virtualTop & ", " & virtualWidth & "x" & virtualHeight & ")"
    Exit Sub
    
CenterOnScreen:
    ' Fallback: center on primary screen
    Debug.Print "ApplyOptimalPositioning: Using fallback - center on primary screen"
    Me.StartUpPosition = 1  ' Center on screen
End Sub

Private Sub UpdateInterface()
    ' DEBUG: Confirm this method is called
    Debug.Print "UpdateInterface called"
    
    ' Preserve current focus to prevent Close button from stealing focus
    Dim currentFocus As Control
    On Error Resume Next
    Set currentFocus = Me.ActiveControl
    On Error GoTo 0
    
    ' Set the main label to show the entire string (no truncation)
    If Len(cellData.OriginalText) > 0 Then
        lblInstructions.Caption = "Selected: " & cellData.OriginalText
        Debug.Print "  Updated lblInstructions to show full text: " & lblInstructions.Caption
    Else
        lblInstructions.Caption = "Selected: [No data]"
        Debug.Print "  No original text data available"
    End If
    
    ' Optional: Update cell count label if it exists
    On Error Resume Next
    If cellData.SelectedCellCount = 1 Then
        lblCellCount.Caption = "Processing: 1 cell"
    Else
        lblCellCount.Caption = "Processing: " & cellData.SelectedCellCount & " cells"
    End If
    Debug.Print "  Cell count: " & cellData.SelectedCellCount
    On Error GoTo 0
    
    ' Update button captions with segment previews
    UpdateButtonCaptions
    
    ' Update Undo button state based on available undo data
    UpdateUndoButtonState
    
    ' Restore focus to prevent unwanted focus changes
    On Error Resume Next
    If Not currentFocus Is Nothing Then
        ' Only restore focus if the control is still enabled and visible
        If currentFocus.Enabled And currentFocus.Visible Then
            currentFocus.SetFocus
            Debug.Print "  Restored focus to: " & currentFocus.Name
        End If
    End If
    On Error GoTo 0
End Sub

Private Sub UpdateButtonCaptions()
    ' DEBUG: Confirm this method is called and show segment data
    Debug.Print "UpdateButtonCaptions called"
    Debug.Print "  Segment data available:"
    Debug.Print "    Segment1: '" & cellData.Segment1 & "' (length: " & Len(cellData.Segment1) & ")"
    Debug.Print "    Segment2: '" & cellData.Segment2 & "' (length: " & Len(cellData.Segment2) & ")"
    Debug.Print "    Segment3: '" & cellData.Segment3 & "' (length: " & Len(cellData.Segment3) & ")"
    Debug.Print "    ActivationID: '" & cellData.ActivationID & "' (length: " & Len(cellData.ActivationID) & ")"
    
    ' Update button captions with hybrid approach: disable buttons and grey out text for unavailable segments
    If Len(cellData.Segment1) > 0 Then 
        btn1.Enabled = True
        btn1.Caption = "1: " & Left(cellData.Segment1, 12)
        btn1.ForeColor = RGB(0, 0, 0)  ' Black text for available segments
        Debug.Print "  Updated btn1 to: " & btn1.Caption & " (enabled)"
    Else
        btn1.Enabled = False
        btn1.Caption = "1: N/A"
        btn1.ForeColor = RGB(128, 128, 128)  ' Grey text for unavailable segments
        Debug.Print "  Updated btn1 to N/A (disabled and greyed)"
    End If
    
    If Len(cellData.Segment2) > 0 Then 
        btn2.Enabled = True
        btn2.Caption = "2: " & Left(cellData.Segment2, 12)
        btn2.ForeColor = RGB(0, 0, 0)
        Debug.Print "  Updated btn2 to: " & btn2.Caption & " (enabled)"
    Else
        btn2.Enabled = False
        btn2.Caption = "2: N/A"
        btn2.ForeColor = RGB(128, 128, 128)
        Debug.Print "  Updated btn2 to N/A (disabled and greyed)"
    End If
    
    If Len(cellData.Segment3) > 0 Then 
        btn3.Enabled = True
        btn3.Caption = "3: " & Left(cellData.Segment3, 12)
        btn3.ForeColor = RGB(0, 0, 0)
        Debug.Print "  Updated btn3 to: " & btn3.Caption & " (enabled)"
    Else
        btn3.Enabled = False
        btn3.Caption = "3: N/A"
        btn3.ForeColor = RGB(128, 128, 128)
        Debug.Print "  Updated btn3 to N/A (disabled and greyed)"
    End If
    
    If Len(cellData.Segment4) > 0 Then 
        btn4.Enabled = True
        btn4.Caption = "4: " & Left(cellData.Segment4, 12)
        btn4.ForeColor = RGB(0, 0, 0)
        Debug.Print "  Updated btn4 to: " & btn4.Caption & " (enabled)"
    Else
        btn4.Enabled = False
        btn4.Caption = "4: N/A"
        btn4.ForeColor = RGB(128, 128, 128)
        Debug.Print "  Updated btn4 to N/A (disabled and greyed)"
    End If
    
    If Len(cellData.Segment5) > 0 Then 
        btn5.Enabled = True
        btn5.Caption = "5: " & Left(cellData.Segment5, 12)
        btn5.ForeColor = RGB(0, 0, 0)
        Debug.Print "  Updated btn5 to: " & btn5.Caption & " (enabled)"
    Else
        btn5.Enabled = False
        btn5.Caption = "5: N/A"
        btn5.ForeColor = RGB(128, 128, 128)
        Debug.Print "  Updated btn5 to N/A (disabled and greyed)"
    End If
    
    If Len(cellData.Segment6) > 0 Then 
        btn6.Enabled = True
        btn6.Caption = "6: " & Left(cellData.Segment6, 12)
        btn6.ForeColor = RGB(0, 0, 0)
        Debug.Print "  Updated btn6 to: " & btn6.Caption & " (enabled)"
    Else
        btn6.Enabled = False
        btn6.Caption = "6: N/A"
        btn6.ForeColor = RGB(128, 128, 128)
        Debug.Print "  Updated btn6 to N/A (disabled and greyed)"
    End If
    
    If Len(cellData.Segment7) > 0 Then 
        btn7.Enabled = True
        btn7.Caption = "7: " & Left(cellData.Segment7, 12)
        btn7.ForeColor = RGB(0, 0, 0)
        Debug.Print "  Updated btn7 to: " & btn7.Caption & " (enabled)"
    Else
        btn7.Enabled = False
        btn7.Caption = "7: N/A"
        btn7.ForeColor = RGB(128, 128, 128)
        Debug.Print "  Updated btn7 to N/A (disabled and greyed)"
    End If
    
    If Len(cellData.Segment8) > 0 Then 
        btn8.Enabled = True
        btn8.Caption = "8: " & Left(cellData.Segment8, 12)
        btn8.ForeColor = RGB(0, 0, 0)
        Debug.Print "  Updated btn8 to: " & btn8.Caption & " (enabled)"
    Else
        btn8.Enabled = False
        btn8.Caption = "8: N/A"
        btn8.ForeColor = RGB(128, 128, 128)
        Debug.Print "  Updated btn8 to N/A (disabled and greyed)"
    End If
    
    If Len(cellData.Segment9) > 0 Then 
        btn9.Enabled = True
        btn9.Caption = "9: " & Left(cellData.Segment9, 12)
        btn9.ForeColor = RGB(0, 0, 0)
        Debug.Print "  Updated btn9 to: " & btn9.Caption & " (enabled)"
    Else
        btn9.Enabled = False
        btn9.Caption = "9: N/A"
        btn9.ForeColor = RGB(128, 128, 128)
        Debug.Print "  Updated btn9 to N/A (disabled and greyed)"
    End If
    
    If Len(cellData.ActivationID) > 0 Then 
        btnActivationID.Enabled = True
        ' Show full activation ID since they're always exactly 12 characters
        btnActivationID.Caption = "ID: " & cellData.ActivationID
        btnActivationID.ForeColor = RGB(0, 0, 0)
        Debug.Print "  Updated btnActivationID to: " & btnActivationID.Caption & " (enabled)"
    Else
        btnActivationID.Enabled = False
        btnActivationID.Caption = "ID: N/A"
        btnActivationID.ForeColor = RGB(128, 128, 128)
        Debug.Print "  Updated btnActivationID to N/A (disabled and greyed)"
    End If
    
    ' Handle TargetingAcronymCleanButton - only visible when no pipes present and caret pattern exists
    On Error Resume Next
    If InStr(cellData.OriginalText, "|") > 0 Then
        ' Data has pipes - this is taxonomy data, hide targeting button and label
        TargetingAcronymCleanButton.Visible = False
        AcronymCleanLabel.Visible = False
        Debug.Print "  Hidden TargetingAcronymCleanButton and AcronymCleanLabel (pipes present)"
    Else
        ' No pipes - check for targeting acronym pattern
        Dim targetingPattern As String
        targetingPattern = ExtractTargetingPattern(cellData.OriginalText)
        
        If Len(targetingPattern) > 0 Then
            ' Found targeting pattern - show button and label with pattern
            TargetingAcronymCleanButton.Visible = True
            TargetingAcronymCleanButton.Enabled = True
            TargetingAcronymCleanButton.Caption = "Trim: " & targetingPattern
            TargetingAcronymCleanButton.ForeColor = RGB(0, 0, 0)
            AcronymCleanLabel.Visible = True
            Debug.Print "  Shown TargetingAcronymCleanButton and AcronymCleanLabel: " & TargetingAcronymCleanButton.Caption
        Else
            ' No targeting pattern found - hide button and label
            TargetingAcronymCleanButton.Visible = False
            AcronymCleanLabel.Visible = False
            Debug.Print "  Hidden TargetingAcronymCleanButton and AcronymCleanLabel (no pattern)"
        End If
    End If
    On Error GoTo 0
    
    Debug.Print "UpdateButtonCaptions completed"
End Sub

' New method for modeless operation - called when user changes selection
Public Sub UpdateForNewSelection(target As Range)
    On Error GoTo ErrorHandler
    
    ' Only update if the selection contains valid taxonomy data
    If target.Cells.Count > 0 And Len(Trim(target.Cells(1).Value)) > 0 Then
        Dim firstCellContent As String
        firstCellContent = target.Cells(1).Value
        
        ' Check if it looks like taxonomy data (contains pipes)
        If InStr(firstCellContent, "|") > 0 Then
            ' Parse the new data
            Dim newParsedData As ParsedCellData
            newParsedData = ParseFirstCellData(firstCellContent, target.Cells.Count)
            
            ' Update our internal data
            cellData = newParsedData
            
            ' Refresh the interface
            UpdateInterface
            
            Debug.Print "UpdateForNewSelection: Updated form for new selection: " & firstCellContent
        Else
            ' Not taxonomy data, but provide feedback
            lblInstructions.Caption = "Selected: " & firstCellContent & " (no pipe-delimited data)"
            Debug.Print "UpdateForNewSelection: Selected data has no pipes, not updating buttons"
        End If
    Else
        ' Empty selection
        lblInstructions.Caption = "Selected: (empty selection)"
        Debug.Print "UpdateForNewSelection: Empty selection"
    End If
    
    Exit Sub

ErrorHandler:
    Debug.Print "UpdateForNewSelection Error: " & Err.Description
    ' Don't show message box in modeless mode - would interrupt user workflow
End Sub

Public Sub UpdateUndoButtonState()
    ' Update Undo button appearance and caption based on multi-step undo stack
    ' Shows dynamic count of available undo operations and manages warning label
    
    Debug.Print "UpdateUndoButtonState called - UndoOperationCount: " & TaxonomyExtractorModule.UndoOperationCount
    
    ' Don't update button appearance if it's currently processing
    If Me.Tag = "UNDO_PROCESSING" Then
        Debug.Print "  Skipping button update - undo is processing"
        Exit Sub
    End If
    
    If TaxonomyExtractorModule.UndoOperationCount = 0 Then
        ' Disable button with grey appearance when no undo operations available
        btnUndo.Enabled = False
        btnUndo.ForeColor = RGB(128, 128, 128)  ' Grey text for disabled state
        btnUndo.Caption = "Undo Last"
        Debug.Print "  Undo button disabled (no operations available)"
    ElseIf TaxonomyExtractorModule.UndoOperationCount = 1 Then
        ' Enable button with normal appearance for single operation
        btnUndo.Enabled = True
        btnUndo.ForeColor = RGB(0, 0, 0)  ' Black text for enabled state
        btnUndo.BackColor = RGB(240, 240, 240)  ' Normal button background
        btnUndo.Caption = "Undo Last (1)"
        Debug.Print "  Undo button enabled (1 operation available)"
    Else
        ' Enable button with operation count for multiple operations
        btnUndo.Enabled = True
        btnUndo.ForeColor = RGB(0, 0, 0)  ' Black text for enabled state
        btnUndo.BackColor = RGB(240, 240, 240)  ' Normal button background
        btnUndo.Caption = "Undo Last (" & TaxonomyExtractorModule.UndoOperationCount & ")"
        Debug.Print "  Undo button enabled (" & TaxonomyExtractorModule.UndoOperationCount & " operations available)"
    End If
    
    ' Handle capacity warning label visibility
    On Error Resume Next  ' Handle case where label doesn't exist yet
    If TaxonomyExtractorModule.UndoOperationCount = 10 Then
        lblUndoWarning.Visible = True
        Debug.Print "  Undo warning label shown (capacity reached)"
    Else
        lblUndoWarning.Visible = False
        Debug.Print "  Undo warning label hidden"
    End If
    On Error GoTo 0
End Sub

' Helper function to restore focus to a specific button after extraction operations
Private Sub RestoreFocusToClickedButton(targetButton As Control)
    On Error Resume Next
    ' Small delay to let extraction operations complete
    DoEvents
    ' Restore focus to the button that was clicked
    If targetButton.Enabled And targetButton.Visible Then
        targetButton.SetFocus
        Debug.Print "RestoreFocusToClickedButton: Focus restored to " & targetButton.Name
    End If
    On Error GoTo 0
End Sub

Private Sub btn1_Click(): Call ExtractPipeSegment(1): Call RestoreFocusToClickedButton(btn1): End Sub
Private Sub btn2_Click(): Call ExtractPipeSegment(2): Call RestoreFocusToClickedButton(btn2): End Sub  
Private Sub btn3_Click(): Call ExtractPipeSegment(3): Call RestoreFocusToClickedButton(btn3): End Sub
Private Sub btn4_Click(): Call ExtractPipeSegment(4): Call RestoreFocusToClickedButton(btn4): End Sub
Private Sub btn5_Click(): Call ExtractPipeSegment(5): Call RestoreFocusToClickedButton(btn5): End Sub
Private Sub btn6_Click(): Call ExtractPipeSegment(6): Call RestoreFocusToClickedButton(btn6): End Sub
Private Sub btn7_Click(): Call ExtractPipeSegment(7): Call RestoreFocusToClickedButton(btn7): End Sub
Private Sub btn8_Click(): Call ExtractPipeSegment(8): Call RestoreFocusToClickedButton(btn8): End Sub
Private Sub btn9_Click(): Call ExtractPipeSegment(9): Call RestoreFocusToClickedButton(btn9): End Sub
Private Sub btnActivationID_Click(): Call ExtractActivationID: Call RestoreFocusToClickedButton(btnActivationID): End Sub
Private Sub TargetingAcronymCleanButton_Click(): Call CleanTargetingAcronyms: Call RestoreFocusToClickedButton(TargetingAcronymCleanButton): End Sub
Private Sub btnUndo_Click()
    ' Check global flag first - exit immediately if undo already in progress
    If TaxonomyExtractorModule.UndoInProgress Then
        Debug.Print "btnUndo_Click: Blocked - undo already in progress"
        Exit Sub
    End If
    
    ' Set global flag and disable events immediately
    TaxonomyExtractorModule.UndoInProgress = True
    Application.EnableEvents = False
    
    ' Immediately disable button to prevent rapid clicking
    btnUndo.Enabled = False
    btnUndo.Caption = "Processing..."
    btnUndo.ForeColor = RGB(128, 128, 128)
    Me.Tag = "UNDO_PROCESSING"
    
    ' Re-enable events for normal operation
    Application.EnableEvents = True
    
    ' Process pending events to ensure visual update
    DoEvents
    
    ' Proceed with undo operation
    Call UndoTaxonomyCleaning
End Sub
Private Sub btnClose_Click(): Unload Me: End Sub

' Cleanup when form is terminated (important for modeless operation)
Private Sub UserForm_Terminate()
    ' Cleanup application events if this was used in modeless mode
    Call CleanupModelessEvents
    Debug.Print "UserForm_Terminate: Cleaned up modeless events"
End Sub

' BENEFITS OF THIS SMART USERFORM:
' =================================
' - Clean, professional interface with 9 clearly labeled buttons + Activation ID button
' - SMART DATA PREVIEW: Shows truncated view of your actual selected data
' - DYNAMIC BUTTON CAPTIONS: Buttons show previews of what each segment contains
' - CONTEXT-AWARE: Interface adapts to show your real data content
' - SMART POSITIONING: Centers form within Excel window for optimal placement
'   • Simple, reliable positioning using Excel's window properties
'   • Always appears in the center of Excel's application window
'   • Falls back to screen center if positioning fails
' - No typing required - just click the segment you want
' - Immediate visual feedback of both data content and extraction results
' - Much faster workflow for frequent use with live previews
' - Looks and feels like a proper Excel tool
' - Built-in UNDO button to reverse the last operation
' - Custom undo functionality with instant operation (Excel's built-in Undo doesn't work with VBA changes)

' FUNCTIONALITY:
' ==============
' - Segments 1-9: Extract specific pipe-delimited segments
' - Activation ID: Extract text after colon character
' - Trim ^ABC^: Remove targeting acronyms in format ^any_characters^ with optional trailing space (only visible when pattern detected)
' - Undo Last: Multi-step undo with LIFO behavior, shows operation count (e.g., "Undo Last (3)")
' - Close: Close the dialog
'
' EXAMPLE DATA:
' =============
' For text: "FY24_26|Q1-4|Tourism WA|WA |Always On Remarketing| 4LAOSO | SOC|Facebook_Instagram|Conversions:DJTDOM060725"
' - Segment 1 → "FY24_26"
' - Segment 3 → "Tourism WA" 
' - Segment 5 → "Always On Remarketing"
' - Segment 9 → "Conversions"
' - Activation ID → "DJTDOM060725"
'
' For targeting acronym text: "^AT^ testing string", "^ACX123^Acxiom Targeting", or "^FB_Campaign^ Facebook data"
' - Clean ^ABC^ → "testing string", "Acxiom Targeting", or "Facebook data" (removes any ^pattern^ with optional trailing space)
'
' QUICK SETUP GUIDE FOR SMART INTERFACE:
' =======================================
' 1. Insert UserForm → Name it "TaxonomyExtractorForm"
' 2. Add Label → Name: "lblInstructions" (for data preview)
' 3. Add 9 CommandButtons → Names: "btn1" through "btn9" (for segments)
' 4. Add 1 CommandButton → Name: "btnActivationID" (for activation ID)
' 5. Add 2 CommandButtons → Names: "btnUndo", "btnClose"
' 6. Copy VBA code above into UserForm module
' 7. Test with sample data: "FY24_26|Q1-4|Tourism WA|WA|Marketing:ABC123"
' 8. Label should show "Selected: FY24_26|Q1-4|Tourism WA|WA|Marketing:ABC123" (complete text)
' 9. Buttons should show "1: FY24_26", "2: Q1-4", "3: Tourism WA", etc. (12 chars each)
' 10. ID button should show "ID: ABC123" (full activation ID)
' 11. Missing segments/ID will show "N/A" with disabled state and grey text (e.g., "7: N/A" greyed out)
'
'================================================================================


================================================
FILE: TaxonomyExtractorModule.vb
================================================
'================================================================================
' EXCEL TAXONOMY EXTRACTOR - Main Module
'================================================================================
' 
' INSTALLATION INSTRUCTIONS:
' 1. Open Excel VBA Editor (Alt + F11)
' 2. Right-click your project → Insert → Module
' 3. Copy and paste this entire code into the new module
' 4. Optionally create the UserForm (see TaxonomyExtractorForm.vb for instructions)
'
' USAGE:
' 1. Select cells with pipe-delimited text (e.g., "Marketing|Campaign|Q4|Social|Facebook")
' 2. Run the TaxonomyExtractor macro (assign to button or use Alt+F8)
' 3. Choose segment number to extract that specific part
'
' EXAMPLES:
' For text "FY24_26|Q1-4|Tourism WA|WA |Always On Remarketing| 4LAOSO | SOC|Facebook_Instagram|Conversions:DJTDOM060725":
' - Segment 1: "FY24_26" (1st segment)
' - Segment 3: "Tourism WA" (3rd segment) 
' - Segment 5: "Always On Remarketing" (5th segment)
' - Segment 9: "Conversions" (9th segment)
' - Activation ID: "DJTDOM060725" (after colon)
'================================================================================

' Global variables for UNDO functionality
Type UndoData
    CellAddress As String
    OriginalValue As String
End Type

' Data structure to hold parsed segments from first selected cell
Type ParsedCellData
    OriginalText As String
    TruncatedDisplay As String
    SelectedCellCount As Long
    Segment1 As String
    Segment2 As String
    Segment3 As String
    Segment4 As String
    Segment5 As String
    Segment6 As String
    Segment7 As String
    Segment8 As String
    Segment9 As String
    ActivationID As String
End Type

' Multi-step undo operation structure
Type UndoOperation
    Description As String           ' "Extract Segment 3", "Extract Activation ID"
    CellChanges() As UndoData      ' Array of cell changes for this operation
    CellCount As Integer           ' Number of cells changed in this operation
    OperationId As Integer         ' Unique identifier for debugging
    Timestamp As Date              ' When operation was performed
End Type

' Multi-step undo stack (up to 10 operations)
Dim UndoStack(1 To 10) As UndoOperation
Public UndoOperationCount As Integer    ' Number of operations in stack
Dim NextOperationId As Integer          ' For assigning unique IDs
Public UndoInProgress As Boolean        ' Global flag to prevent rapid clicking

' Legacy variables for backward compatibility during transition
Dim UndoArray() As UndoData
Public UndoCount As Integer
Dim LastSegmentNumber As Integer

' Global variable to hold ribbon reference (optional)
Public myRibbon As Object

' Global variable for modeless form event handling
Public AppEvents As clsAppEvents


' Main macro to be called when button is pressed
Sub TaxonomyExtractor()
    ' Check if cells are selected
    If Selection.Cells.Count = 0 Then
        MsgBox "Please select cells containing text before running this tool.", vbExclamation, "No Selection"
        Exit Sub
    End If
    
    ' Check if selection contains text
    Dim hasText As Boolean
    hasText = False
    Dim cell As Range
    For Each cell In Selection
        If Len(Trim(cell.Value)) > 0 Then
            hasText = True
            Exit For
        End If
    Next cell
    
    If Not hasText Then
        MsgBox "Please select cells that contain text.", vbExclamation, "No Text Found"
        Exit Sub
    End If
    
    ' Parse the first selected cell
    Dim firstCellContent As String
    firstCellContent = Selection.Cells(1).Value
    
    ' DEBUG: Show what we're parsing
    Debug.Print "TaxonomyExtractor: First cell content: " & firstCellContent
    
    Dim parsedData As ParsedCellData
    parsedData = ParseFirstCellData(firstCellContent, Selection.Cells.Count)
    
    ' DEBUG: Show parsed results
    Debug.Print "TaxonomyExtractor: Parsed data:"
    Debug.Print "  Original: " & parsedData.OriginalText
    Debug.Print "  Truncated: " & parsedData.TruncatedDisplay
    Debug.Print "  Segment1: " & parsedData.Segment1
    Debug.Print "  Segment2: " & parsedData.Segment2
    Debug.Print "  Segment3: " & parsedData.Segment3
    Debug.Print "  ActivationID: " & parsedData.ActivationID
    
    ' Show the UserForm and pass the parsed data
    Debug.Print "TaxonomyExtractor: Calling SetParsedData..."
    TaxonomyExtractorForm.SetParsedData parsedData
    Debug.Print "TaxonomyExtractor: Showing form..."
    TaxonomyExtractorForm.Show
End Sub

' Modeless version - allows interaction with Excel while form is open
Sub TaxonomyExtractorModeless()
    ' Check if cells are selected
    If Selection.Cells.Count = 0 Then
        MsgBox "Please select cells containing text before running this tool.", vbExclamation, "No Selection"
        Exit Sub
    End If
    
    ' Check if selection contains text
    Dim hasText As Boolean
    hasText = False
    Dim cell As Range
    For Each cell In Selection
        If Len(Trim(cell.Value)) > 0 Then
            hasText = True
            Exit For
        End If
    Next cell
    
    If Not hasText Then
        MsgBox "Please select cells that contain text.", vbExclamation, "No Text Found"
        Exit Sub
    End If
    
    ' Initialize application events for selection tracking
    Set AppEvents = New clsAppEvents
    Set AppEvents.App = Application
    
    ' Parse the first selected cell
    Dim firstCellContent As String
    firstCellContent = Selection.Cells(1).Value
    
    Dim parsedData As ParsedCellData
    parsedData = ParseFirstCellData(firstCellContent, Selection.Cells.Count)
    
    ' Show the UserForm as modeless and pass the parsed data
    TaxonomyExtractorForm.SetParsedData parsedData
    TaxonomyExtractorForm.Show vbModeless
    
    ' Give the UserForm immediate focus and set focus to first available button
    On Error Resume Next
    ' Set focus to the first available segment button for immediate usability
    If TaxonomyExtractorForm.btn1.Enabled Then
        TaxonomyExtractorForm.btn1.SetFocus
    ElseIf TaxonomyExtractorForm.btnActivationID.Enabled Then
        TaxonomyExtractorForm.btnActivationID.SetFocus
    Else
        ' Fallback to Close button if no segments available
        TaxonomyExtractorForm.btnClose.SetFocus
    End If
    On Error GoTo 0
End Sub

' Simple input dialog interface (fallback when UserForm doesn't exist)
Sub ShowSegmentSelector()
    Dim selectedSegment As String
    Dim validNumber As Integer
    
    ' Show clean, simple interface
    selectedSegment = InputBox("TAXONOMY EXTRACTOR - Segment Extractor" & vbCrLf & vbCrLf & _
                              "This tool extracts specific segments from pipe-delimited data." & vbCrLf & vbCrLf & _
                              "EXAMPLE: 'FY24_26|Q1-4|Tourism WA|WA |Always On Remarketing| 4LAOSO | SOC|Facebook_Instagram|Conversions:DJTDOM060725'" & vbCrLf & _
                              "  Segment 1 = FY24_26" & vbCrLf & _
                              "  Segment 3 = Tourism WA" & vbCrLf & _
                              "  Segment 5 = Always On Remarketing" & vbCrLf & _
                              "  Segment 9 = Conversions" & vbCrLf & _
                              "  A = DJTDOM060725 (Activation ID)" & vbCrLf & vbCrLf & _
                              "Enter segment number (1-9) or 'A' for Activation ID:", "Taxonomy Extractor", "")
    
    ' Validate and execute
    If selectedSegment = "" Then Exit Sub ' User cancelled
    
    ' Check for Activation ID
    If UCase(Trim(selectedSegment)) = "A" Then
        Call ExtractActivationID
    ElseIf IsNumeric(selectedSegment) Then
        validNumber = CInt(selectedSegment)
        If validNumber >= 1 And validNumber <= 9 Then
            Call ExtractPipeSegment(validNumber)
        Else
            MsgBox "Please enter a number between 1 and 9, or 'A' for Activation ID.", vbExclamation, "Invalid Input"
        End If
    Else
        MsgBox "Please enter a valid number between 1 and 9, or 'A' for Activation ID.", vbExclamation, "Invalid Input"
    End If
End Sub

' Parse first selected cell into individual segments
Function ParseFirstCellData(cellContent As String, selectedCellCount As Long) As ParsedCellData
    Dim result As ParsedCellData
    
    ' Store original text and cell count
    result.OriginalText = cellContent
    result.SelectedCellCount = selectedCellCount
    
    ' Create truncated display (12 chars + "...")
    If Len(cellContent) > 15 Then
        result.TruncatedDisplay = Left(cellContent, 12) & "..."
    Else
        result.TruncatedDisplay = cellContent
    End If
    
    ' Split by colon first to separate activation ID
    Dim colonParts() As String
    colonParts = Split(cellContent, ":")
    
    Dim mainContent As String
    mainContent = colonParts(0)
    
    ' Extract activation ID if colon exists
    If UBound(colonParts) > 0 Then
        result.ActivationID = Trim(colonParts(1))
    Else
        result.ActivationID = ""
    End If
    
    ' Only parse segments if there are actual pipe characters
    ' Without pipes, this is not taxonomy data and all segments should be empty
    If InStr(mainContent, "|") > 0 Then
        ' Split main content by pipes
        Dim segments() As String
        segments = Split(mainContent, "|")
        
        ' Assign segments (with bounds checking)
        If UBound(segments) >= 0 Then result.Segment1 = Trim(segments(0))
        If UBound(segments) >= 1 Then result.Segment2 = Trim(segments(1))
        If UBound(segments) >= 2 Then result.Segment3 = Trim(segments(2))
        If UBound(segments) >= 3 Then result.Segment4 = Trim(segments(3))
        If UBound(segments) >= 4 Then result.Segment5 = Trim(segments(4))
        If UBound(segments) >= 5 Then result.Segment6 = Trim(segments(5))
        If UBound(segments) >= 6 Then result.Segment7 = Trim(segments(6))
        If UBound(segments) >= 7 Then result.Segment8 = Trim(segments(7))
        If UBound(segments) >= 8 Then result.Segment9 = Trim(segments(8))
    Else
        ' No pipes found - leave all segments empty (they default to empty strings)
        ' This will cause all buttons to show "N/A" as intended
    End If
    
    ParseFirstCellData = result
End Function

' Extract the first targeting pattern found in text (for button caption display)
Function ExtractTargetingPattern(inputText As String) As String
    Dim regex As Object
    Dim matches As Object
    
    On Error GoTo ErrorHandler
    
    ' Create regex object for pattern matching
    Set regex = CreateObject("VBScript.RegExp")
    With regex
        .Global = False  ' Only find first match
        .Pattern = "\^[^^]+\^"  ' Matches ^any characters except caret^ (no optional space for display)
    End With
    
    ' Find the first match
    Set matches = regex.Execute(inputText)
    
    If matches.Count > 0 Then
        ExtractTargetingPattern = matches(0).Value
    Else
        ExtractTargetingPattern = ""
    End If
    
    Exit Function
    
ErrorHandler:
    ExtractTargetingPattern = ""
End Function

' Core function to extract specific segment from pipe-delimited text
Sub ExtractPipeSegment(segmentNumber As Integer)
    Dim cell As Range
    Dim cellText As String
    Dim extractedText As String
    Dim pipePositions(1 To 10) As Integer
    Dim pipeCount As Integer
    Dim pos As Integer
    Dim processedCount As Integer
    Dim i As Integer
    Dim colonPos As Integer
    
    ' Add operation to undo stack BEFORE making changes
    Call AddUndoOperation("Extract Segment " & segmentNumber)
    
    ' Legacy variables for backward compatibility
    UndoCount = 0
    LastSegmentNumber = segmentNumber
    ReDim UndoArray(1 To Selection.Cells.Count)
    
    ' Disable screen updating for better performance, then re-enable for visual update
    Application.ScreenUpdating = False
    
    processedCount = 0
    
    For Each cell In Selection
        On Error GoTo NextCell ' Skip any problematic cells
        cellText = CStr(cell.Value)
        
        ' Skip empty cells
        If Len(Trim(cellText)) = 0 Then
            GoTo NextCell
        End If
        
        ' Find all pipe positions
        pipeCount = 0
        pos = 1
        Do While pos <= Len(cellText) And pipeCount < 10
            pos = InStr(pos, cellText, "|")
            If pos = 0 Then Exit Do
            pipeCount = pipeCount + 1
            pipePositions(pipeCount) = pos
            pos = pos + 1
        Loop
        
        ' Extract the requested segment
        If segmentNumber <= pipeCount + 1 Then
            Dim startPos As Integer
            Dim endPos As Integer
            
            If segmentNumber = 1 Then
                ' First segment: from start to first pipe (or entire text if no pipes)
                If pipeCount >= 1 Then
                    startPos = 1
                    endPos = pipePositions(1) - 1
                Else
                    ' No pipes, check for colon
                    startPos = 1
                    colonPos = InStr(cellText, ":")
                    If colonPos > 0 Then
                        endPos = colonPos - 1
                    Else
                        endPos = Len(cellText)
                    End If
                End If
            ElseIf segmentNumber <= pipeCount Then
                ' Middle segments: between two pipes
                startPos = pipePositions(segmentNumber - 1) + 1
                endPos = pipePositions(segmentNumber) - 1
            Else
                ' Last segment: after final pipe, but before colon if present
                startPos = pipePositions(pipeCount) + 1
                colonPos = InStr(startPos, cellText, ":")
                If colonPos > 0 Then
                    endPos = colonPos - 1
                Else
                    endPos = Len(cellText)
                End If
            End If
            
            extractedText = Trim(Mid(cellText, startPos, endPos - startPos + 1))
            
            ' Store original value for undo before changing
            UndoCount = UndoCount + 1
            UndoArray(UndoCount).CellAddress = cell.Address
            UndoArray(UndoCount).OriginalValue = cellText
            
            cell.Value = extractedText
            processedCount = processedCount + 1
        End If
        ' If not enough segments, leave cell unchanged
        
NextCell:
        On Error GoTo 0 ' Reset error handling
    Next cell
    
    ' Re-enable screen updating to show all changes immediately
    Application.ScreenUpdating = True
    
    ' Silent operation - only show errors when nothing processed
    If processedCount = 0 Then
        ' Only show error if nothing was processed
        MsgBox "No cells were processed. Make sure your selected cells have at least " & segmentNumber & " pipe-delimited segment(s).", vbExclamation, "No Changes Made"
        UndoCount = 0 ' Clear undo data if nothing was processed
    End If
    
    ' Ensure screen updating is always re-enabled
    Application.ScreenUpdating = True
    
    ' Refresh modeless UserForm if it's open (v1.4.0 enhancement)
    Call RefreshModelessFormIfOpen
End Sub

' Undo the last taxonomy cleaning operation
Sub UndoTaxonomyCleaning()
    ' Legacy function redirected to new multi-step undo system
    Call UndoLastOperation
End Sub

' Extract Activation ID (text after colon character)
Sub ExtractActivationID()
    Dim cell As Range
    Dim cellText As String
    Dim extractedText As String
    Dim colonPos As Integer
    Dim processedCount As Integer
    
    ' Add operation to undo stack BEFORE making changes
    Call AddUndoOperation("Extract Activation ID")
    
    ' Legacy variables for backward compatibility
    UndoCount = 0
    LastSegmentNumber = 0 ' Special marker for Activation ID
    ReDim UndoArray(1 To Selection.Cells.Count)
    
    ' Disable screen updating for better performance, then re-enable for visual update
    Application.ScreenUpdating = False
    
    processedCount = 0
    
    For Each cell In Selection
        On Error GoTo NextCell ' Skip any problematic cells
        cellText = CStr(cell.Value)
        
        ' Skip empty cells
        If Len(Trim(cellText)) = 0 Then
            GoTo NextCell
        End If
        
        ' Find colon position
        colonPos = InStr(cellText, ":")
        
        If colonPos > 0 Then
            ' Extract text after colon (trim any spaces)
            extractedText = Trim(Mid(cellText, colonPos + 1))
            
            ' Store original value for undo before changing
            UndoCount = UndoCount + 1
            UndoArray(UndoCount).CellAddress = cell.Address
            UndoArray(UndoCount).OriginalValue = cellText
            
            cell.Value = extractedText
            processedCount = processedCount + 1
        End If
        ' If no colon found, leave cell unchanged
        
NextCell:
        On Error GoTo 0 ' Reset error handling
    Next cell
    
    ' Re-enable screen updating to show all changes immediately
    Application.ScreenUpdating = True
    
    ' Silent operation - only show errors when nothing processed
    If processedCount = 0 Then
        ' Only show error if nothing was processed
        MsgBox "No cells were processed. Make sure your selected cells contain colon (:) characters.", vbExclamation, "No Changes Made"
        UndoCount = 0 ' Clear undo data if nothing was processed
    End If
    
    ' Ensure screen updating is always re-enabled
    Application.ScreenUpdating = True
    
    ' Refresh modeless UserForm if it's open (v1.4.0 enhancement)
    Call RefreshModelessFormIfOpen
End Sub

' Clean targeting acronyms (removes text in format ^ABC^ with optional trailing space)
Sub CleanTargetingAcronyms()
    Dim cell As Range
    Dim cellText As String
    Dim cleanedText As String
    Dim processedCount As Integer
    Dim regex As Object
    
    ' Add operation to undo stack BEFORE making changes
    Call AddUndoOperation("Clean Targeting Acronyms")
    
    ' Legacy variables for backward compatibility
    UndoCount = 0
    LastSegmentNumber = -1 ' Special marker for targeting acronym cleaning
    ReDim UndoArray(1 To Selection.Cells.Count)
    
    ' Create regex object for pattern matching
    Set regex = CreateObject("VBScript.RegExp")
    With regex
        .Global = True
        .Pattern = "\^[^^]+\^ ?" ' Matches ^any characters except caret^ with optional trailing space
    End With
    
    ' Disable screen updating for better performance
    Application.ScreenUpdating = False
    
    processedCount = 0
    
    For Each cell In Selection
        On Error GoTo NextCell ' Skip any problematic cells
        cellText = CStr(cell.Value)
        
        ' Skip empty cells
        If Len(Trim(cellText)) = 0 Then
            GoTo NextCell
        End If
        
        ' Check if cell contains targeting acronym pattern
        If regex.Test(cellText) Then
            ' Store original value for undo before changing
            UndoCount = UndoCount + 1
            UndoArray(UndoCount).CellAddress = cell.Address
            UndoArray(UndoCount).OriginalValue = cellText
            
            ' Remove all targeting acronym patterns
            cleanedText = regex.Replace(cellText, "")
            cell.Value = cleanedText
            processedCount = processedCount + 1
        End If
        
NextCell:
        On Error GoTo 0 ' Reset error handling
    Next cell
    
    ' Re-enable screen updating to show all changes immediately
    Application.ScreenUpdating = True
    
    ' Silent operation - only show errors when nothing processed
    If processedCount = 0 Then
        ' Only show error if nothing was processed
        MsgBox "No cells were processed. Make sure your selected cells contain targeting acronyms in format ^ABC^.", vbExclamation, "No Changes Made"
        UndoCount = 0 ' Clear undo data if nothing was processed
    End If
    
    ' Ensure screen updating is always re-enabled
    Application.ScreenUpdating = True
    
    ' Refresh modeless UserForm if it's open
    Call RefreshModelessFormIfOpen
End Sub

' Refresh modeless UserForm after extraction (v1.4.0 UX enhancement)
Sub RefreshModelessFormIfOpen()
    On Error GoTo ErrorHandler
    
    ' Only refresh if UserForm exists and is visible (modeless mode)
    If Not TaxonomyExtractorForm Is Nothing Then
        If TaxonomyExtractorForm.Visible Then
            ' Get current selection and update form with new content
            If Selection.Cells.Count > 0 Then
                Dim firstCellContent As String
                firstCellContent = Selection.Cells(1).Value
                
                ' Parse the updated cell content (now likely a single value, no pipes)
                Dim updatedData As ParsedCellData
                updatedData = ParseFirstCellData(firstCellContent, Selection.Cells.Count)
                
                ' Update the form with new data
                TaxonomyExtractorForm.SetParsedData updatedData
                
                Debug.Print "RefreshModelessFormIfOpen: Updated form after extraction with: " & firstCellContent
            End If
        End If
    End If
    
    Exit Sub
    
ErrorHandler:
    ' Silent error handling - don't interrupt user workflow
    Debug.Print "RefreshModelessFormIfOpen Error: " & Err.Description
End Sub

' Test function to verify segment extraction works correctly
Sub TestSegmentExtraction()
    Dim testText As String
    
    testText = "FY24_26|Q1-4|Tourism WA|WA |Always On Remarketing| 4LAOSO | SOC|Facebook_Instagram|Conversions:DJTDOM060725"
    
    ' Create test cells
    Range("A1").Value = testText
    Range("A2").Value = "Test|Without|Colon|Data" ' Test without colon
    Range("A1:A2").Select
    
    MsgBox "Test data placed in A1:A2. COMPILATION ERROR FIXED!" & vbCrLf & vbCrLf & _
           "A1 (with colon):" & vbCrLf & _
           "• Segment 8 should extract: 'Facebook_Instagram'" & vbCrLf & _
           "• Segment 9 should extract: 'Conversions'" & vbCrLf & _
           "• Activation ID should extract: 'DJTDOM060725'" & vbCrLf & vbCrLf & _
           "A2 (without colon):" & vbCrLf & _
           "• Segment 4 should extract: 'Data'" & vbCrLf & _
           "• Activation ID should show 'no colon' message" & vbCrLf & vbCrLf & _
           "Run TaxonomyExtractor to test these buttons!", vbInformation, "Test Setup Complete"
End Sub

' Quick test of Activation ID extraction directly
Sub TestActivationIDDirect()
    Range("A1").Value = "FY24_26|Q1-4|Tourism WA|WA |Always On Remarketing| 4LAOSO | SOC|Facebook_Instagram|Conversions:DJTDOM060725"
    Range("A1").Select
    Call ExtractActivationID
End Sub

' Test simple positioning - centers UserForm in Excel window
Sub TestSimplePositioning()
    ' Create test data
    Range("B2").Value = "FY24_26|Q1-4|Tourism WA|WA |Always On Remarketing| 4LAOSO | SOC|Facebook_Instagram|Conversions:DJTDOM060725"
    Range("B2").Select
    
    MsgBox "SIMPLE POSITIONING TEST:" & vbCrLf & vbCrLf & _
           "The UserForm will now appear centered within the Excel window." & vbCrLf & _
           "This uses Excel's Application.Left, .Top, .Width, and .Height properties" & vbCrLf & _
           "to calculate the center position reliably.", _
           vbInformation, "Simple Positioning Test"
    
    ' Launch the form to test positioning
    Call TaxonomyExtractor
End Sub

' Test targeting acronym cleaning functionality with smart button behavior and expanded patterns
Sub TestTargetingAcronymCleaning()
    ' Create different types of test data to show smart button behavior with various patterns
    Range("A1").Value = "FY24_26|Q1-4|Tourism WA|WA|Marketing:ABC123"  ' Taxonomy data with pipes
    Range("A2").Value = "^AT^ testing string"                            ' Simple letters pattern
    Range("A3").Value = "^ACX123^Acxiom Targeting"                      ' Letters + numbers pattern 
    Range("A4").Value = "^FB_Campaign^ Facebook data"                   ' Letters + underscore pattern
    Range("A5").Value = "^Multi-Word^ test content"                     ' Multi-word with hyphen pattern
    Range("A6").Value = "^123ABC^ numeric start pattern"               ' Numbers + letters pattern
    Range("A7").Value = "No acronyms here"                              ' Regular text (no pattern)
    Range("A8").Value = "Regular taxonomy data without targeting"        ' Regular text (no pattern)
    
    MsgBox "EXPANDED TARGETING PATTERN TEST:" & vbCrLf & vbCrLf & _
           "Test data placed in A1:A8. Select each row to see smart button visibility:" & vbCrLf & vbCrLf & _
           "A1: 'FY24_26|Q1-4|...' → Trim button HIDDEN (has pipes)" & vbCrLf & _
           "A2: '^AT^ testing string' → Trim button VISIBLE: ^AT^" & vbCrLf & _
           "A3: '^ACX123^Acxiom...' → Trim button VISIBLE: ^ACX123^" & vbCrLf & _
           "A4: '^FB_Campaign^ Facebook...' → Trim button VISIBLE: ^FB_Campaign^" & vbCrLf & _
           "A5: '^Multi-Word^ test...' → Trim button VISIBLE: ^Multi-Word^" & vbCrLf & _
           "A6: '^123ABC^ numeric...' → Trim button VISIBLE: ^123ABC^" & vbCrLf & _
           "A7: 'No acronyms here' → Trim button HIDDEN (no pattern)" & vbCrLf & _
           "A8: 'Regular taxonomy...' → Trim button HIDDEN (no pattern)" & vbCrLf & vbCrLf & _
           "Button overlays Segment 1 and only appears when needed! Use MODELESS mode!", _
           vbInformation, "Expanded Targeting Pattern Test"
    
    ' Select first row and launch modeless form for easy testing
    Range("A1").Select
    Call TaxonomyExtractorModeless
End Sub

'================================================================================
' RIBBON CALLBACK FUNCTIONS
'================================================================================
' These functions are called by the CustomUI ribbon buttons embedded in the XLAM file.
' DO NOT MODIFY the function names - they must match the onAction attributes in customUI.xml

' Ribbon callback function - called when IPG Taxonomy Extractor ribbon button is clicked
Public Sub RibbonTaxonomyExtractor(control As Object)
    On Error GoTo ErrorHandler
    
    ' Call the modeless extractor function (v1.4.0 - superior user experience)
    TaxonomyExtractorModeless
    Exit Sub
    
ErrorHandler:
    MsgBox "Error launching IPG Taxonomy Extractor: " & Err.Description, vbCritical, "IPG Taxonomy Extractor v1.6.0"
End Sub

' Ribbon callback function - called when IPG Taxonomy Extractor (Modeless) ribbon button is clicked
Public Sub RibbonTaxonomyExtractorModeless(control As Object)
    On Error GoTo ErrorHandler
    
    ' Call the modeless extractor function
    TaxonomyExtractorModeless
    Exit Sub
    
ErrorHandler:
    MsgBox "Error launching IPG Taxonomy Extractor (Modeless): " & Err.Description, vbCritical, "IPG Taxonomy Extractor v1.6.0"
End Sub

' Cleanup function for modeless form - called when UserForm is closed
Public Sub CleanupModelessEvents()
    On Error Resume Next
    If Not AppEvents Is Nothing Then
        AppEvents.Cleanup
        Set AppEvents = Nothing
    End If
    On Error GoTo 0
End Sub

' ============================================================================
' MULTI-STEP UNDO SYSTEM
' ============================================================================

' Add a new operation to the undo stack, capturing current cell states BEFORE changes
Public Sub AddUndoOperation(description As String)
    On Error GoTo ErrorHandler
    
    ' Increment operation count, managing 10-operation limit
    If UndoOperationCount >= 10 Then
        ' Remove oldest operation (shift array left)
        Dim i As Integer
        For i = 1 To 9
            UndoStack(i) = UndoStack(i + 1)
        Next i
        UndoOperationCount = 9
    End If
    
    UndoOperationCount = UndoOperationCount + 1
    NextOperationId = NextOperationId + 1
    
    ' Initialize the new operation
    With UndoStack(UndoOperationCount)
        .Description = description
        .OperationId = NextOperationId
        .Timestamp = Now
        .CellCount = 0
        
        ' Capture current state of all selected cells BEFORE any changes
        ReDim .CellChanges(1 To Selection.Cells.Count)
        
        Dim cell As Range
        Dim cellIndex As Integer
        cellIndex = 0
        
        For Each cell In Selection
            If Len(cell.Value) > 0 Then  ' Only capture cells with content
                cellIndex = cellIndex + 1
                .CellChanges(cellIndex).CellAddress = cell.Address
                .CellChanges(cellIndex).OriginalValue = cell.Value
                .CellCount = .CellCount + 1
            End If
        Next cell
        
        ' Resize array to actual count
        If .CellCount > 0 Then
            ReDim Preserve .CellChanges(1 To .CellCount)
        End If
    End With
    
    Debug.Print "AddUndoOperation: Added '" & description & "' (ID: " & NextOperationId & ") affecting " & UndoStack(UndoOperationCount).CellCount & " cells"
    
    Exit Sub
    
ErrorHandler:
    Debug.Print "AddUndoOperation Error: " & Err.Description
    ' Don't let undo system errors interrupt operations
End Sub

' Undo the most recent operation (LIFO - Last In, First Out)
Public Sub UndoLastOperation()
    On Error GoTo ErrorHandler
    
    ' Check if there are operations to undo
    If UndoOperationCount = 0 Then
        MsgBox "No operations to undo.", vbInformation, "Nothing to Undo"
        Exit Sub
    End If
    
    ' Button is already disabled by the click handler
    ' Just proceed with the undo operation
    On Error GoTo ErrorHandler
    
    ' Get the most recent operation
    Dim currentOp As UndoOperation
    currentOp = UndoStack(UndoOperationCount)
    
    Debug.Print "UndoLastOperation: Undoing '" & currentOp.Description & "' (ID: " & currentOp.OperationId & ")"
    
    ' Disable screen updating for performance
    Application.ScreenUpdating = False
    
    ' Restore all cells from this operation
    Dim i As Integer
    Dim cell As Range
    
    For i = 1 To currentOp.CellCount
        On Error Resume Next  ' Handle invalid cell references gracefully
        Set cell = Range(currentOp.CellChanges(i).CellAddress)
        If Not cell Is Nothing Then
            cell.Value = currentOp.CellChanges(i).OriginalValue
            Debug.Print "  Restored " & cell.Address & " to: " & currentOp.CellChanges(i).OriginalValue
        End If
        On Error GoTo ErrorHandler
    Next i
    
    ' Remove this operation from the stack
    UndoOperationCount = UndoOperationCount - 1
    
    ' Re-enable screen updating
    Application.ScreenUpdating = True
    
    Debug.Print "UndoLastOperation: Complete. Operations remaining: " & UndoOperationCount
    
    ' Refresh the UI to show updated state
    Call RefreshModelessFormIfOpen
    
    ' Re-enable undo button after brief delay to prevent rapid clicking issues
    Call ReenableUndoButtonAfterDelay
    
    Exit Sub
    
ErrorHandler:
    Application.ScreenUpdating = True
    Debug.Print "UndoLastOperation Error: " & Err.Description
    MsgBox "Error during undo operation: " & Err.Description, vbCritical, "Undo Error"
    ' Clear flags and re-enable undo button immediately if error occurred
    UndoInProgress = False
    On Error Resume Next
    If Not TaxonomyExtractorForm Is Nothing Then
        If TaxonomyExtractorForm.Visible Then
            TaxonomyExtractorForm.Tag = ""
            TaxonomyExtractorForm.btnUndo.Enabled = True
            Call TaxonomyExtractorForm.UpdateUndoButtonState
        End If
    End If
    On Error GoTo 0
End Sub

' Re-enable undo button after a brief delay to prevent rapid clicking issues
Private Sub ReenableUndoButtonAfterDelay()
    ' Use a simple timer approach with Application.Wait for 500ms delay
    Dim startTime As Double
    startTime = Timer
    
    ' Brief delay to allow cell operations to complete and provide visual feedback
    Application.Wait Now + TimeValue("00:00:01")  ' 1 second delay for better responsiveness
    
    ' Re-enable the undo button and restore proper state
    On Error Resume Next
    If Not TaxonomyExtractorForm Is Nothing Then
        If TaxonomyExtractorForm.Visible Then
            ' Clear processing flags
            TaxonomyExtractorForm.Tag = ""
            UndoInProgress = False
            ' Re-enable the button first
            TaxonomyExtractorForm.btnUndo.Enabled = True
            ' Update button state will handle caption and colors correctly
            Call TaxonomyExtractorForm.UpdateUndoButtonState
            ' Restore focus to undo button after re-enabling
            If TaxonomyExtractorForm.btnUndo.Enabled Then
                TaxonomyExtractorForm.btnUndo.SetFocus
            End If
            Debug.Print "ReenableUndoButtonAfterDelay: Focus restored to Undo button"
            Debug.Print "ReenableUndoButtonAfterDelay: Undo button re-enabled"
        End If
    End If
    On Error GoTo 0
End Sub

' Clear all operations from the undo stack
Public Sub ClearUndoStack()
    UndoOperationCount = 0
    NextOperationId = 0
    Debug.Print "ClearUndoStack: All undo operations cleared"
End Sub

' Get description of the most recent operation (for UI display)
Public Function GetTopUndoDescription() As String
    If UndoOperationCount > 0 Then
        GetTopUndoDescription = UndoStack(UndoOperationCount).Description
    Else
        GetTopUndoDescription = ""
    End If
End Function

' Optional: Ribbon load callback - called when the ribbon is loaded
Public Sub RibbonOnLoad(ribbon As Object)
    Set myRibbon = ribbon
End Sub

